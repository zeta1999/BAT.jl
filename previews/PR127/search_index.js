var documenterSearchIndex = {"docs":
[{"location":"publications/#Publications-and-Talks-1","page":"Publications and Talks","title":"Publications and Talks","text":"","category":"section"},{"location":"publications/#","page":"Publications and Talks","title":"Publications and Talks","text":"... to be written ...","category":"page"},{"location":"basics/#Statistical-Basics-1","page":"Statistical Basics","title":"Statistical Basics","text":"","category":"section"},{"location":"basics/#","page":"Statistical Basics","title":"Statistical Basics","text":"... to be written ...","category":"page"},{"location":"installation/#Installation-1","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation/#","page":"Installation","title":"Installation","text":"BAT.jl is written in the Julia programming language. To use BAT.jl, you will need to install Julia itself, the BAT.jl Julia package, and some additional Julia packages. Depending on your use case, you may also want to need a Python installation with certain Python packages (optional).","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"Table of contents:","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"Pages = [\"installation.md\"]\nDepth = 3","category":"page"},{"location":"installation/#Installing-Julia-1","page":"Installation","title":"Installing Julia","text":"","category":"section"},{"location":"installation/#","page":"Installation","title":"Installation","text":"Julia is available for Linux, OS-X and Windows, and easy to install:","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"Download Julia.\nExtract the archive, resp. run the installer.\nYou may want to add the Julia bin directory to your $PATH. To get the location of the Julia bin directory on OS-X or Windows, start a Julia session (via applications menu) and run the Julia command Sys.BINDIR.","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"note: Note\nBAT.jl requires Julia >= v1.3.","category":"page"},{"location":"installation/#Installing-Jupyter-and-matplotlib/pyplot-(optional)-1","page":"Installation","title":"Installing Jupyter and matplotlib/pyplot (optional)","text":"","category":"section"},{"location":"installation/#","page":"Installation","title":"Installation","text":"If you plan to use Jupyter notebooks and/or the matplotlib/pyplot backend of the Julia Plots.jl package, you will also need a Python installation and certain Python packages (see below). BAT.jl is fully usable without Jupyter and matplotlib/pyplot, but both can come in very handy.","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"Julia can either use existing installations of Jupyter and pyplot , or install both internally by creating an internal Conda installation within $HOME/.julia/conda. We recommend the first approach (especially using Anaconda), since Julia will otherwise have to download over 1 GB of software, the $HOME/.julia directory will grow very large, and you will need to start Jupyter in an indirect fashion via Julia (only to have Jupyter then start additional Julia instances as Jupyter kernels in return).","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"For details, see the IJulia.jl, PyCall.jl and PyPlot.jl documentation (you should not need to if you follow the steps below).","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"On Linux, Julia (more specifically the Julia packages IJulia.jl, PyCall.jl, and PyPlot.jl) will by default try to use the matplotlib/pyplot installation associated with the python3 (resp. python) executable on your $PATH. Likewise, Julia will by default try to use the Jupyter installation associated with the jupyter executable on your $PATH.","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"However, on OS-X and Windows, both IJulia.jl and PyCall.jl by default always create a Julia-internal Conda installation (see above), even if Jupyter and matplotlib/pyplot are available (apparently broken Jupyter/Python installations on these platforms caused frequent support requests).  In contrast to this default behavior, we recommend to use a standalone Jupyter and Python installation on all OS platforms. Set the environment variables $JUPYTER and $PYTHON to point to your Jupyter and Python executable to force Julia to use the existing installation.","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"We recommend that you install the Anaconda Python distribution, it includes both Jupyter and pyplot (it is of course possible to use non-Anaconda Jupyter and pyplot installations instead).","category":"page"},{"location":"installation/#Installing-Anaconda-(optional)-1","page":"Installation","title":"Installing Anaconda (optional)","text":"","category":"section"},{"location":"installation/#","page":"Installation","title":"Installation","text":"To install Anaconda","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"Download Anaconda.\nRun the installer\nSet the environment variables $JUPYTER and $PYTHON to the full path of the Jupyter and Python executables (see above).\nNote: OS-X => v1.15 (\"Catalina\") by default uses the \"zsh\" shell instead of \"bash\". However, the Anaconda installer (at least in some versions) still seems to add add it's $PATH settings to \"HOMEbash_profile instead of HOME/.zshrc\". You may have to copy the Anaconda-related section to the correct file.","category":"page"},{"location":"installation/#Environment-variables-1","page":"Installation","title":"Environment variables","text":"","category":"section"},{"location":"installation/#","page":"Installation","title":"Installation","text":"You may want/need to set the following environment variables:","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"$PATH: Include the Julia bin-directory in your binary search path, see above.","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"If you intend to use Jupyter, you will probably want to include the directory containing the jupyter binary to your PATH as well.","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"$JULIA_NUM_THREADS: Number of threads to use for Julia multi-threading\n$JULIA_DEPOT_PATH and JULIA_PKG_DEVDIR: If you want Julia to install packages in another location than $HOME/.julia.","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"See the Julia manual for a description of other Julia-specific environment variables.","category":"page"},{"location":"installation/#Installing-BAT.jl-and-related-Julia-packages-1","page":"Installation","title":"Installing BAT.jl and related Julia packages","text":"","category":"section"},{"location":"installation/#","page":"Installation","title":"Installation","text":"BAT.jl is provided as a registered Julia package. To install it, simply run","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"julia> using Pkg\njulia> pkg\"add BAT\"","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"However, you will likely need other Julia packages too. We recommend that you install certain statistics, plotting, I/O and array packages as well:","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"julia> using Pkg\njulia> pkg\"add BAT ArraysOfArrays Distributions ElasticArrays IntervalSets Parameters Plots ValueShapes StatsBase Tables TypedTables\"","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"To install the latest development version of BAT (master branch), instead of the latest stable release, use","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"julia> pkg\"add BAT#master\"","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"If you'd like to precompile all installed packages right aways (otherwise they'll get precompiled when loaded for the first time), run","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"julia> pkg\"precompile\"","category":"page"},{"location":"installation/#Installing-additional-Julia-packages-1","page":"Installation","title":"Installing additional Julia packages","text":"","category":"section"},{"location":"installation/#HDF5-(File-I/O)-1","page":"Installation","title":"HDF5 (File I/O)","text":"","category":"section"},{"location":"installation/#","page":"Installation","title":"Installation","text":"To enable BAT's HDF5 file I/O capabilities, add the package \"HDF5.jl\":","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"pkg\"add HDF5\"","category":"page"},{"location":"installation/#IJulia-(Jupyter-Julia-kernel)-1","page":"Installation","title":"IJulia (Jupyter Julia kernel)","text":"","category":"section"},{"location":"installation/#","page":"Installation","title":"Installation","text":"To use the the Julia Jupyter kernel, you need to add the package \"IJulia.jl\":","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"On Linux, simply use","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"pkg\"add IJulia\"","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"On OS-X, if you have an existing Jupyter installation (e.g. via Anaconda) and would like Julia to use it (instead of an internal Conda installation, see above), use (e.g.)","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"ENV[\"JUPYTER\"] = \"$(homedir())/opt/anaconda3/bin/jupyter\"; pkg\"add IJulia\"","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"On Windows, if would like Julia to use an existing Jupyter installation (see above), use something like","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"ENV[\"JUPYTER\"] = \"DRIVE:/path/to/your/anaconda/.../jupyter.exe\"; pkg\"add IJulia\"","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"Julia will remember the chosen Jupyter installation permanently, ENV[\"JUPYTER\"] only needs to be set the first time you run pkg\"add IJulia\".","category":"page"},{"location":"installation/#PyPlot-(optinal-backend-for-Plots.jl)-1","page":"Installation","title":"PyPlot (optinal backend for Plots.jl)","text":"","category":"section"},{"location":"installation/#","page":"Installation","title":"Installation","text":"To use the Plots.jl matplotlib/pyplot backend (see above), add the package \"PyPlot.jl\". To call Python code from Julia yourself directly, you may want to add \"PyCall.jl\" as well:","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"On Linux, use:","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"pkg\"add PyPlot PyCall\"","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"On OS-X, if you have an existing Python/matplotlib/pyplot installation and would like Julia to use it (see above), use (e.g.):","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"ENV[\"PYTHON\"] = \"$(homedir())/opt/anaconda3/bin/python\", pkg\"add PyPlot PyCall\"","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"On Windows, if would like Julia to use an existing Python installation (see above), use something like:","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"ENV[\"PYTHON\"] = \"DRIVE:/path/to/your/anaconda/.../python.exe\"; pkg\"add PyPlot PyCall\"","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"Julia will remember the chosen Python installation permanently, ENV[\"PYTHON\"] only needs to be set the first time you run pkg\"add PyPlot PyCall\".","category":"page"},{"location":"installation/#Additional-customization-options-1","page":"Installation","title":"Additional customization options","text":"","category":"section"},{"location":"installation/#","page":"Installation","title":"Installation","text":"Note: If you want Julia to install packages in another location than $HOME/.julia, set the environment variables JULIA_DEPOT_PATH and JULIA_PKG_DEVDIR (see above).","category":"page"},{"location":"benchmarks/#Benchmarks-and-Performance-Tests-1","page":"Benchmarks and Performance Tests","title":"Benchmarks and Performance Tests","text":"","category":"section"},{"location":"benchmarks/#","page":"Benchmarks and Performance Tests","title":"Benchmarks and Performance Tests","text":"... to be written ...","category":"page"},{"location":"stable_api/#API-Documentation-1","page":"API Documentation","title":"API Documentation","text":"","category":"section"},{"location":"stable_api/#","page":"API Documentation","title":"API Documentation","text":"This is the stable public API of BAT. Forward/backward compatibility follows Julia's semantic versioning rules.","category":"page"},{"location":"stable_api/#","page":"API Documentation","title":"API Documentation","text":"DocTestSetup  = quote\n    using BAT\nend","category":"page"},{"location":"stable_api/#Types-1","page":"API Documentation","title":"Types","text":"","category":"section"},{"location":"stable_api/#","page":"API Documentation","title":"API Documentation","text":"Pages = [\"stable_api.md\"]\nOrder = [:type]","category":"page"},{"location":"stable_api/#Functions-and-macros-1","page":"API Documentation","title":"Functions and macros","text":"","category":"section"},{"location":"stable_api/#","page":"API Documentation","title":"API Documentation","text":"Pages = [\"stable_api.md\"]\nOrder = [:macro, :function]","category":"page"},{"location":"stable_api/#Documentation-1","page":"API Documentation","title":"Documentation","text":"","category":"section"},{"location":"stable_api/#","page":"API Documentation","title":"API Documentation","text":"bat_findmedian\nbat_findmode\nbat_marginalmode\nbat_integrate\nbat_read\nbat_rng\nbat_sample\nbat_write\n\nBAT.default_mode_estimator\nBAT.default_sampling_algorithm\nBAT.density_logval\nBAT.density_logvalgrad\n\nAbstractDensity\nAbstractMCMCTuningStrategy\nAbstractPosteriorDensity\nAbstractWeightingScheme\nAdaptiveMetropolisTuning\nAHMC\nARPWeighting\nBrooksGelmanConvergence\nDensitySample\nDensitySampleVector\nDistLikeDensity\nGelmanRubinConvergence\nLinDVal\nLogDVal\nMaxDensityLBFGS\nMaxDensityNelderMead\nMaxDensitySampleSearch\nMCMCAlgorithm\nMCMCBurninStrategy\nMCMCInitStrategy\nMCMCIterator\nMetropolisHastings\nModeAsDefined\nPosteriorDensity\nRandResampling\nRandSampling\nRepetitionWeighting\n\nBAT.AbstractModeEstimator\nBAT.AbstractSamplingAlgorithm\nBAT.AnyPosterior\nBAT.GenericDensity\n\nValueShapes.totalndof\nValueShapes.varshape","category":"page"},{"location":"stable_api/#BAT.bat_findmedian","page":"API Documentation","title":"BAT.bat_findmedian","text":"bat_findmedian(\n    samples::DensitySampleVector\n)::DensitySampleVector\n\nThe function computes the median of marginalized samples.\n\nReturns a NamedTuple of the shape\n\n(result = X::DensitySampleVector, ...)\n\n\n\n\n\n","category":"function"},{"location":"stable_api/#BAT.bat_findmode","page":"API Documentation","title":"BAT.bat_findmode","text":"bat_findmode(\n    posterior::BAT.AnyPosterior,\n    [algorithm::BAT.AbstractModeEstimator];\n    initial_mode::Union{Missing,DensitySampleVector,Any} = missing\n)::DensitySampleVector\n\nEstiate the global mode of posterior.\n\nReturns a NamedTuple of the shape\n\n(result = X::DensitySampleVector, ...)\n\nProperties others than mode are algorithm-specific, they are also by default not part of the stable BAT API.\n\n\n\n\n\n","category":"function"},{"location":"stable_api/#BAT.bat_marginalmode","page":"API Documentation","title":"BAT.bat_marginalmode","text":"bat_marginalmode(\n    samples::DensitySampleVector;\n    nbins::Union{Integer, Symbol} = 200\n)::DensitySampleVector\n\nEstimates a local mode of samples by finding the maximum of marginalized posterior for each dimension.\n\nReturns a NamedTuple of the shape\n\n(result = X::DensitySampleVector, ...)\n\nnbins specifies the number of bins that are used for marginalization. The default value is nbins=200. The optimal number of bins can be estimated using  the following keywords:\n\n:sqrt  — Square-root choice\n:sturges — Sturges' formula\n:rice — Rice Rule\n:scott — Scott's normal reference rule\n:fd —  Freedman–Diaconis rule\n\n\n\n\n\n","category":"function"},{"location":"stable_api/#BAT.bat_integrate","page":"API Documentation","title":"BAT.bat_integrate","text":"bat_integrate(\n    posterior::BAT.AnyPosterior,\n)::DensitySampleVector\n\nCalculate the integral (evidence) of posterior.\n\nReturns a NamedTuple: (result = x::Measurement.Measurement, ...)\n\nResult properties not listed here are algorithm-specific and are not part of the stable BAT API.\n\nposterior may be a\n\nBAT.AbstractPosteriorDensity\nBAT.DistLikeDensity\nBAT.DensitySampleVector\nDistributions.MultivariateDistribution\n\nUses the AHMI algorithm by default.\n\n\n\n\n\n","category":"function"},{"location":"stable_api/#BAT.bat_read","page":"API Documentation","title":"BAT.bat_read","text":"bat_read(filename::AbstractString, data)\nbat_read(fn_with_subpath::Tuple{AbstractString, AbstractString}, data)\n\nRead data from a file filename, resp. from an internal sub-path of the file (if supported by the file format), e.g. an HDF5 group.\n\nCurrently supported file formats are:\n\nHDF5 with file extension \".h5\" or \".hdf5\"\n\n\n\n\n\n","category":"function"},{"location":"stable_api/#BAT.bat_rng","page":"API Documentation","title":"BAT.bat_rng","text":"bat_rng()\n\nReturn a new BAT-compatible random number generator, with a random seed drawn from the system entropy pool.\n\n\n\n","category":"function"},{"location":"stable_api/#BAT.bat_sample","page":"API Documentation","title":"BAT.bat_sample","text":"bat_sample(\n    [rng::AbstractRNG],\n    posterior::BAT.AnyPosterior,\n    n::BAT.AnyNSamples,\n    [algorithm::BAT.AbstractSamplingAlgorithm]\n)::DensitySampleVector\n\nDraw n samples from posterior.\n\nReturns a NamedTuple of the shape\n\n(result = X::DensitySampleVector, ...)\n\nResult properties not listed here are algorithm-specific and are not part of the stable BAT API.\n\nposterior may be a\n\nBAT.AbstractPosteriorDensity\nBAT.DistLikeDensity\nBAT.DensitySampleVector\nDistributions.MultivariateDistribution\n\nDepending on the type of posterior, n may be of type\n\nInteger: Number of samples\nTuple{Integer,Integer}: Tuple of number of samples per sample source  and number of sample sources (e.g. number of MCMC chains). The total number  of samples is product(n).\n\nDepending on the type of posterior, the number of samples returned may be somewhat larger or smaller than specified by product(n).\n\nAlso depending on the posterior type, the samples may be independent or correlated (e.g. when using MCMC).\n\n\n\n\n\n","category":"function"},{"location":"stable_api/#BAT.bat_write","page":"API Documentation","title":"BAT.bat_write","text":"bat_write(filename::AbstractString, data)\nbat_write(fn_with_subpath::Tuple{AbstractString, AbstractString}, data)\n\nWrite data to a file filename, resp. to an internal sub-path of the file (if supported by the file format), e.g. an HDF5 group.\n\nCurrently supported file formats are:\n\nHDF5 with file extension \".h5\" or \".hdf5\"\n\n\n\n\n\n","category":"function"},{"location":"stable_api/#BAT.default_mode_estimator","page":"API Documentation","title":"BAT.default_mode_estimator","text":"BAT.default_mode_estimator(posterior)\n\nGet BAT's default optimization algorithm for posterior.\n\n\n\n\n\n","category":"function"},{"location":"stable_api/#BAT.default_sampling_algorithm","page":"API Documentation","title":"BAT.default_sampling_algorithm","text":"BAT.default_sampling_algorithm(posterior)\n\nGet BAT's default sampling algorithm for posterior.\n\n\n\n\n\n","category":"function"},{"location":"stable_api/#BAT.density_logval","page":"API Documentation","title":"BAT.density_logval","text":"BAT.density_logval(density::AbstractDensity, v::Any)\n\nCompute log of the value of a multivariate density function for the given variate/parameter-values.\n\nInput:\n\ndensity: density function\nv: argument, i.e. variate / parameter-values\n\nNote: If density_logval is called with an argument that is out of bounds, the behaviour is undefined. The result for arguments that are not within bounds is implicitly -Inf, but it is the caller's responsibility to handle these cases.\n\n\n\n","category":"function"},{"location":"stable_api/#BAT.density_logvalgrad","page":"API Documentation","title":"BAT.density_logvalgrad","text":"BAT.density_logvalgrad(density::AbstractDensity, v::AbstractVector{<:Real})\n\nCompute the log of the value of a multivariate density function, as well as the gradient of the log-value for the given variate/parameter-values.\n\nInput:\n\ndensity: density function\nv: argument, i.e. variate / parameter-values\n\nReturns a tuple of the log density value and it's gradient.\n\nSee also BAT.density_logval.\n\n\n\n","category":"function"},{"location":"stable_api/#BAT.AbstractDensity","page":"API Documentation","title":"BAT.AbstractDensity","text":"AbstractDensity\n\nSubtypes of AbstractDensity must implement the function\n\nBAT.density_logval\n\nFor likelihood densities this is typically sufficient, since shape, and variate bounds will be inferred from the prior.\n\nDensities with a known variate shape may also implement\n\nValueShapes.varshape\n\nDensities with known variate bounds may also implement\n\nBAT.var_bounds\n\nnote: Note\nThe function BAT.var_bounds is not part of the stable public BAT-API, it's name and arguments may change without notice.\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.AbstractMCMCTuningStrategy","page":"API Documentation","title":"BAT.AbstractMCMCTuningStrategy","text":"AbstractMCMCTuningStrategy\n\nAbstract super-type for MCMC tuning strategies.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.AbstractPosteriorDensity","page":"API Documentation","title":"BAT.AbstractPosteriorDensity","text":"abstract type AbstractPosteriorDensity <: AbstractDensity end\n\nAbstract super-type for posterior probability densities.\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.AbstractWeightingScheme","page":"API Documentation","title":"BAT.AbstractWeightingScheme","text":"AbstractWeightingScheme{T<:Real}\n\nAbstract class for sample weighting schemes.\n\nWeight values will have type T.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.AdaptiveMetropolisTuning","page":"API Documentation","title":"BAT.AdaptiveMetropolisTuning","text":"AdaptiveMetropolisTuning(...)\n\nAdaptive MCMC tuning strategy for Metropolis-Hastings samplers.\n\nAdapts the proposal function based on the acceptance ratio and covariance of the previous samples.\n\nFields:\n\nλ: Controls the weight given to new covariance information in adapting the proposal distribution. Defaults to 0.5.\nα: Metropolis-Hastings acceptance ratio target, tuning will try to adapt the proposal distribution to bring the acceptance ratio inside this interval. Defaults to IntervalSets.ClosedInterval(0.15, 0.35)\nβ: Controls how much the spread of the proposal distribution is widened/narrowed depending on the current MH acceptance ratio.\nc: Interval for allowed scale/spread of the proposal distribution. Defaults to ClosedInterval(1e-4, 1e2).\nr: Reweighting factor. Take accumulated sample statistics of previous tuning cycles into account with a relative weight of r. Set to 0 to completely reset sample statistics between each tuning cycle.\n\nConstructors:\n\nAdaptiveMetropolisTuning(\n    λ::Real,\n    α::IntervalSets.ClosedInterval{<:Real},\n    β::Real,\n    c::IntervalSets.ClosedInterval{<:Real},\n    r::Real\n)\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.AHMC","page":"API Documentation","title":"BAT.AHMC","text":"@with_kw struct AHMC <: MCMCAlgorithm     metric::HMCMetric = DiagEuclideanMetric()     gradient::Module = ForwardDiff     integrator::HMCIntegrator = LeapfrogIntegrator()     proposal::HMCProposal = NUTS()     adaptor::HMCAdaptor = StanHMCAdaptor() end\n\nKeyword arguments\n\nAlso see AdvancedHMC.jl for more detailed information on the following HMC related keyword arguments.\n\nMetric\n\noptions:\n\nDiagEuclideanMetric()\nUnitEuclideanMetric()\nDenseEuclideanMetric()\n\ndefault: metric = DiagEuclideanMetric()\n\nIntegrator\n\noptions:\n\nLeapfrogIntegrator(step_size::Float64 = 0.0)\nJitteredLeapfrogIntegrator(step_size::Float64 = 0.0, jitter_rate::Float64 = 1.0)\nTemperedLEapfrogIntegrator(step_size::Float64 = 0.0, tempering_rate::Float64 = 1.05)\n\ndefault: integrator = LeapfrogIntegrator(step_size::Float64 = 0.0) For step_size = 0.0, the initial stepsize is determined using AdvancedHMC.find_good_stepsize()\n\nProposal\n\noptions:\n\nFixedStepNumber(n_steps::Int64 = 10)\nFixedTrajectoryLength(trajectory_length::Float64 = 2.0)\nNUTS(sampling::Symbol, nuts::Symbol)\n\nwith     - sampling = :SliceTS or :MultinomialTS     - nuts = :ClassicNoUTurn or  :GeneralisedNoUTUrn\n\ndefault: proposal = NUTS(sampling::Symbol = :MultinomialTS, nuts::Symbol = :ClassicNoUTurn)\n\nAdaptor\n\noptions:\n\nMassMatrixAdaptor()\nStepSizeAdaptor(step_size::Float64 = 0.8)\nNaiveHMCAdaptor(step_size::Float64 = 0.8)\nStanHMCAdaptor(step_size::Float64 = 0.8)\n\ndefault: adaptor =  StanHMCAdaptor(step_size::Float64 = 0.8)\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.ARPWeighting","page":"API Documentation","title":"BAT.ARPWeighting","text":"struct ARPWeighting{T<:AbstractFloat} <: AbstractWeightingScheme{T}\n\nSample weighting scheme suitable for accept/reject-based sampling algorithms (e.g. MetropolisHastings). Both accepted and rejected samples become part of the output, with a weight proportional to their original acceptance probability.\n\nConstructors:\n\nARPWeighting()\n\nARPWeighting{T}()\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.BrooksGelmanConvergence","page":"API Documentation","title":"BAT.BrooksGelmanConvergence","text":"BrooksGelmanConvergence\n\nBrooks-Gelman maximum(R^2) convergence test.\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.DensitySample","page":"API Documentation","title":"BAT.DensitySample","text":"struct DensitySample\n\nA weighted sample drawn according to an statistical density, e.g. a BAT.AbstractDensity.\n\nFields:     * v: Multivariate parameter vector     * logd: log of the value of the density at v     * weight: Weight of the sample     * info: Additional info on the provenance of the sample. Content depends        on the sampling algorithm.     * aux: Custom user-defined information attatched to the sample.\n\nConstructors:\n\nDensitySample(\n    v::AbstractVector{<:Real},\n    logd::Real,\n    weight::Real,\n    info::Any,\n    aux::Any\n)\n\nUse DensitySampleVector to store vectors of multiple samples with an efficient column-based memory layout.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.DensitySampleVector","page":"API Documentation","title":"BAT.DensitySampleVector","text":"DensitySampleVector\n\nType alias for StructArrays.StructArray{<:DensitySample,...}.\n\nConstructor:\n\n    DensitySampleVector(\n        (\n            v::AbstractVector{<:AbstractVector{<:Real}}\n            logd::AbstractVector{<:Real}\n            weight::AbstractVector{<:Real}\n            info::AbstractVector{<:Any}\n            aux::AbstractVector{<:Any}\n        )\n    )\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.DistLikeDensity","page":"API Documentation","title":"BAT.DistLikeDensity","text":"DistLikeDensity <: AbstractDensity\n\nA density that implements part of the Distributions.Distribution interface. Such densities are suitable to be used as a priors.\n\nTypically, custom priors should be implemented as subtypes of Distributions.Distribution. BAT will automatically wrap them in a subtype of DistLikeDensity.\n\nSubtypes of DistLikeDensity are required to support more functionality than a AbstractDensity, but less than a Distribution{Multivariate,Continuous}.\n\nA d::Distribution{Multivariate,Continuous} can be converted into (wrapped in) an DistLikeDensity via conv(DistLikeDensity, d).\n\nThe following functions must be implemented for subtypes:\n\nBAT.density_logval\nBAT.var_bounds\nValueShapes.varshape\nDistributions.sampler\nStatistics.cov\n\nnote: Note\nThe function BAT.var_bounds is not part of the stable public BAT-API, it's name and arguments may change without notice.\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.GelmanRubinConvergence","page":"API Documentation","title":"BAT.GelmanRubinConvergence","text":"GelmanRubinConvergence\n\nGelman-Rubin maximum(R^2) convergence test.\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.LinDVal","page":"API Documentation","title":"BAT.LinDVal","text":"LinDVal{T<:Real}\n\nRepresent the linear value of a statistical density at some point. LinDVal provides means to unambiguously distinguish between linear and log result values of density functions.\n\nConstructor:\n\nLinDVal(d::Real)\n\nUse BAT.density_logval to extract the logarithm of the density value from a LinDVal:\n\n    BAT.density_logval(LinDVal(logd)) == logd\n\nSee also LogDVal, AbstractDensity and BAT.GenericDensity.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.LogDVal","page":"API Documentation","title":"BAT.LogDVal","text":"LogDVal{T<:Real}\n\nRepresent the logarithm of the value of a statistical density at some point. LogDVal provides means to unambiguously distinguish between linear and log result values of density functions.\n\nConstructor:\n\nLogDVal(logd::Real)\n\nUse BAT.density_logval to extract the actual log-density value from a LogDVal:\n\n    BAT.density_logval(LogDVal(logd)) == logd\n\nSee also LogDVal, AbstractDensity and BAT.GenericDensity.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.MaxDensityLBFGS","page":"API Documentation","title":"BAT.MaxDensityLBFGS","text":"MaxDensityLBFGS <: AbstractModeEstimator\n\nConstructors:\n\nMaxDensityLBFGS()\n\nEstimate the mode of the posterior using LBFGS optimization (via Optim.jl). The gradient of the posterior is computer by forward-mode auto-differentiation (via ForwardDiff.jl).\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.MaxDensityNelderMead","page":"API Documentation","title":"BAT.MaxDensityNelderMead","text":"MaxDensityNelderMead <: AbstractModeEstimator\n\nConstructors:\n\nMaxDensityNelderMead()\n\nEstimate the mode of the posterior using Nelder-Mead optimization (via Optim.jl).\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.MaxDensitySampleSearch","page":"API Documentation","title":"BAT.MaxDensitySampleSearch","text":"MaxDensitySampleSearch <: AbstractModeEstimator\n\nConstructors:\n\nMaxDensitySampleSearch()\n\nEstimate the mode as the variate with the highest posterior density value within a given set of samples.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.MCMCAlgorithm","page":"API Documentation","title":"BAT.MCMCAlgorithm","text":"abstract type MCMCAlgorithm <: AbstractSamplingAlgorithm end\n\nnote: Note\nThe details of the MCMCIterator and MCMCAlgorithm API (see below) currently do not form part of the BAT-API, and may change without notice.\n\nThe following methods must be defined for subtypes (e.g. for SomeAlgorithm<:MCMCAlgorithm):\n\n(spec::MCMCSpec{<:SomeAlgorithm})(chainid::Integer)::MCMCIterator\n\nIn some cases, these custom methods may be necessary (default methods are defined for MCMCAlgorithm):\n\nBAT.mcmc_startval!(\n    x::Union{AbstractVector{<:Real},VectorOfSimilarVectors{<:Real}},\n    rng::AbstractRNG,\n    posterior::AbstractPosteriorDensity,\n    algorithm::SomeAlgorithm\n)\n\nTo implement a new MCMC algorithm, subtypes of both MCMCAlgorithm and MCMCIterator are required.\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.MCMCBurninStrategy","page":"API Documentation","title":"BAT.MCMCBurninStrategy","text":"@with_kw struct MCMCBurninStrategy\n\nDefines the MCMC burn-in strategy, specifically the number and length of MCMC tuning/burn-in cycles. Fields:\n\nmax_nsamples_per_cycle: Maximum number of MCMC samples to generate per cycle, defaults to 1000. Definition of a sample depends on MCMC algorithm.\nmax_nsteps_per_cycle: Maximum number of MCMC steps per cycle, defaults to 10000. Definition of a step depends on MCMC algorithm.\nmax_time_per_cycle: Maximum wall-clock time to spend per cycle, in seconds. Defaults to Inf.\nmax_ncycles: Maximum number of cycles.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.MCMCInitStrategy","page":"API Documentation","title":"BAT.MCMCInitStrategy","text":"@with_kw struct MCMCInitStrategy\n\nDefines the MCMC chain initialization strategy. Fields:\n\ninit_tries_per_chain: Interval that specifies the minimum and maximum number of tries per MCMC chain to find a suitable starting position. Many candidate chains will be created and run for a short time. The chains with the best performance will be selected for tuning/burn-in and MCMC sampling run. Defaults to IntervalSets.ClosedInterval(8, 128).\nmax_nsamples_init: Maximum number of MCMC samples for each candidate chain. Defaults to 25. Definition of a sample depends on sampling algorithm.\nmax_nsteps_init: Maximum number of MCMC steps for each candidate chain. Defaults to 250. Definition of a step depends on sampling algorithm.\nmax_time_init::Int: Maximum wall-clock time to spend per candidate chain, in seconds. Defaults to Inf.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.MCMCIterator","page":"API Documentation","title":"BAT.MCMCIterator","text":"abstract type MCMCIterator end\n\nRepresents the current state of a MCMC chain.\n\nnote: Note\nThe details of the MCMCIterator and MCMCAlgorithm API (see below) currently do not form part of the BAT-API, and may change without notice.\n\nTo implement a new MCMC algorithm, subtypes of both MCMCAlgorithm and MCMCIterator are required.\n\nThe following methods must be defined for subtypes of MCMCIterator (e.g. SomeMCMCIter<:MCMCIterator):\n\nBAT.mcmc_spec(chain::SomeMCMCIter)::MCMCSpec\n\nBAT.getrng(chain::SomeMCMCIter)::AbstractRNG\n\nBAT.mcmc_info(chain::SomeMCMCIter)::MCMCIteratorInfo\n\nBAT.nsteps(chain::SomeMCMCIter)::Int\n\nBAT.nsamples(chain::SomeMCMCIter)::Int\n\nBAT.current_sample(chain::SomeMCMCIter)::DensitySample\n\nBAT.sample_type(chain::SomeMCMCIter)::Type{<:DensitySample}\n\nBAT.samples_available(chain::SomeMCMCIter, nonzero_weights::Bool = false)::Bool\n\nBAT.get_samples!(appendable, chain::SomeMCMCIter, nonzero_weights::Bool)::typeof(appendable)\n\nBAT.next_cycle!(chain::SomeMCMCIter)::SomeMCMCIter\n\nBAT.mcmc_step!(\n    callback::AbstractMCMCCallback,\n    chain::SomeMCMCIter\n)\n\nThe following methods are implemented by default:\n\nalgorithm(chain::MCMCIterator)\ngetposterior(chain::MCMCIterator)\nrngseed(chain::MCMCIterator)\nDensitySampleVector(chain::MCMCIterator)\nmcmc_iterate!(callback, chain::MCMCIterator, ...)\nmcmc_iterate!(callbacks, chains::AbstractVector{<:MCMCIterator}, ...)\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.MetropolisHastings","page":"API Documentation","title":"BAT.MetropolisHastings","text":"MetropolisHastings\n\nMetropolis-Hastings MCMC sampling algorithm.\n\nConstructors:\n\nMetropolisHastings()\nMetropolisHastings(weighting::AbstractWeightingScheme)\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.ModeAsDefined","page":"API Documentation","title":"BAT.ModeAsDefined","text":"ModeAsDefined <: AbstractModeEstimator\n\nConstructors:\n\nModeAsDefined()\n\nGet the mode as defined by the density, resp. the underlying distribution (if available), via StatsBase.mode.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.PosteriorDensity","page":"API Documentation","title":"BAT.PosteriorDensity","text":"PosteriorDensity{\n    Li<:AbstractDensity,\n    Pr<:DistLikeDensity,\n    ...\n} <: AbstractPosteriorDensity\n\nA representation of a PosteriorDensity, based a likelihood and prior, a representation of the posterior density is cached internally. The densities be accessed via\n\ngetlikelihood(posterior::PosteriorDensity)::Li\ngetprior(posterior::PosteriorDensity)::Pr\n\nConstructors:\n\nPosteriorDensity(likelihood::AbstractDensity, prior::AbstractDensity)\nPosteriorDensity(likelihood::Any, prior::Any)\nPosteriorDensity(log_likelihood::Function, prior::Any)\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.RandResampling","page":"API Documentation","title":"BAT.RandResampling","text":"RandResampling <: AbstractSamplingAlgorithm\n\nConstructors:\n\nRandResampling()\n\nResamples from a given set of samples.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.RandSampling","page":"API Documentation","title":"BAT.RandSampling","text":"RandSampling\n\nConstructors:\n\nRandSampling()\n\nSample via Random.rand. Only supported for posteriors of type Distributions.MultivariateDistribution and BAT.DistLikeDensity.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.RepetitionWeighting","page":"API Documentation","title":"BAT.RepetitionWeighting","text":"struct RepetitionWeighting{T<:AbstractFloat} <: AbstractWeightingScheme{T}\n\nSample weighting scheme suitable for sampling algorithms which may repeated samples multiple times in direct succession (e.g. MetropolisHastings). The repeated sample is stored only once, with a weight equal to the number of times it has been repeated (e.g. because a Markov chain has not moved during a sampling step).\n\nConstructors:\n\nRepetitionWeighting()\n\nRepetitionWeighting{T}()\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.AbstractModeEstimator","page":"API Documentation","title":"BAT.AbstractModeEstimator","text":"BAT.AbstractModeEstimator\n\nAbstract type for BAT optimization algorithms.\n\nA typical application for optimization in BAT is mode estimation (see bat_findmode),\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.AbstractSamplingAlgorithm","page":"API Documentation","title":"BAT.AbstractSamplingAlgorithm","text":"BAT.AbstractSamplingAlgorithm\n\nAbstract type for BAT sampling algorithms. See bat_sample.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.AnyPosterior","page":"API Documentation","title":"BAT.AnyPosterior","text":"BAT.AnyPosterior = Union{...}\n\nUnion of all types that BAT will accept as a posterior:\n\nPosteriorDensity\nDensitySampleVector\nDistLikeDensity\nDistributions.MultivariateDistribution\nStatsBase.Histogram\n\n\n\n\n\n","category":"constant"},{"location":"stable_api/#BAT.GenericDensity","page":"API Documentation","title":"BAT.GenericDensity","text":"GenericDensity{F<:Function} <: AbstractDensity\n\nConstructors:\n\nGenericDensity(f)\n\nTurns the density function f into a BAT-compatible [AbstractDensity)(@ref).f(v)must return either a [LogDVal](@ref) (recommended) or a [LinDVal`](@ref).\n\nIt must be safe to execute f in parallel on multiple threads and processes.\n\n\n\n","category":"type"},{"location":"stable_api/#ValueShapes.totalndof","page":"API Documentation","title":"ValueShapes.totalndof","text":"ValueShapes.totalndof(density::AbstractDensity)::Union{Int,Missing}\n\nGet the number of degrees of freedom of the variates of density. May return missing, if the shape of the variates is not fixed.\n\n\n\nValueShapes.totalndof(density::DistLikeDensity)::Int\n\nGet the number of degrees of freedom of the variates of density. Must not be missing, a DistLikeDensity must have a fixed variate shape.\n\n\n\n","category":"function"},{"location":"stable_api/#ValueShapes.varshape","page":"API Documentation","title":"ValueShapes.varshape","text":"ValueShapes.varshape(\n    density::AbstractDensity\n)::Union{ValueShapes.AbstractValueShape,Missing}\n\nValueShapes.varshape(\n    density::DistLikeDensity\n)::ValueShapes.AbstractValueShape\n\nGet the shapes of the variates of density.\n\nFor prior densities, the result must not be missing, but may be nothing if the prior only supports unshaped variate/parameter vectors.\n\n\n\n","category":"function"},{"location":"faq/#Frequently-Asked-Questions-1","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"","category":"section"},{"location":"faq/#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"... to be written ...","category":"page"},{"location":"developing/#Developer-Instructions-1","page":"Developer instructions","title":"Developer Instructions","text":"","category":"section"},{"location":"developing/#Documentation-Generation-1","page":"Developer instructions","title":"Documentation Generation","text":"","category":"section"},{"location":"developing/#","page":"Developer instructions","title":"Developer instructions","text":"To generate and view a local version of the documentation, run","category":"page"},{"location":"developing/#","page":"Developer instructions","title":"Developer instructions","text":"cd docs\njulia make.jl local","category":"page"},{"location":"developing/#","page":"Developer instructions","title":"Developer instructions","text":"then open \"docs/build/index.html\" in your browser.","category":"page"},{"location":"developing/#Code-Reloading-1","page":"Developer instructions","title":"Code Reloading","text":"","category":"section"},{"location":"developing/#","page":"Developer instructions","title":"Developer instructions","text":"When changing the code of BAT.jl and testing snippets and examples in the REPL, automatic code reloading comes in very handy. Try out Revise.jl.","category":"page"},{"location":"internal_api/#Internal-API-1","page":"Internal API","title":"Internal API","text":"","category":"section"},{"location":"internal_api/#","page":"Internal API","title":"Internal API","text":"note: Note\nThis is the documentation of BAT's internal API. The internal API is fully accessible to users, but all aspects of it are subject to change without notice. Functionalities of the internal API that, over time, turn out to require user access (e.g. to support advanced use cases) will be evolved to gain a stable interface and then promoted to the public API.","category":"page"},{"location":"internal_api/#","page":"Internal API","title":"Internal API","text":"DocTestSetup  = quote\n    using BAT\nend","category":"page"},{"location":"internal_api/#Types-1","page":"Internal API","title":"Types","text":"","category":"section"},{"location":"internal_api/#","page":"Internal API","title":"Internal API","text":"Pages = [\"internal_api.md\"]\nOrder = [:type]","category":"page"},{"location":"internal_api/#Functions-and-macros-1","page":"Internal API","title":"Functions and macros","text":"","category":"section"},{"location":"internal_api/#","page":"Internal API","title":"Internal API","text":"Pages = [\"internal_api.md\"]\nOrder = [:macro, :function]","category":"page"},{"location":"internal_api/#Documentation-1","page":"Internal API","title":"Documentation","text":"","category":"section"},{"location":"internal_api/#","page":"Internal API","title":"Internal API","text":"BAT.AbstractMCMCCallback\nBAT.AbstractProposalDist\nBAT.BasicMvStatistics\nBAT.DataSet\nBAT.HMIData\nBAT.HMISettings\nBAT.IntegrationVolume\nBAT.MCMCCallbackWrapper\nBAT.MCMCSpec\nBAT.OnlineMvCov\nBAT.OnlineMvMean\nBAT.OnlineUvMean\nBAT.OnlineUvVar\nBAT.PointCloud\nBAT.SearchResult\nBAT.WhiteningResult\n\n\nBAT.apply_bounds\nBAT.apply_bounds_and_eval_posterior_logval_strict!\nBAT.apply_bounds_and_eval_posterior_logval!\nBAT.apply_bounds!\nBAT.autocrl\nBAT.bat_sampler\nBAT.bg_R_2sqr\nBAT.find_localmodes\nBAT.get_bin_centers\nBAT.create_hypercube\nBAT.create_hyperrectangle\nBAT.distribution_logpdf\nBAT.distribution_logpdf!\nBAT.drop_low_weight_samples\nBAT.effective_sample_size\nBAT.eval_density_logval\nBAT.find_hypercube_centers\nBAT.fromuhc\nBAT.fromuhc!\nBAT.fromui\nBAT.getlikelihood\nBAT.getprior\nBAT.gr_Rsqr\nBAT.hm_init\nBAT.hm_integrate!\nBAT.hm_whiteningtransformation!\nBAT.hyperrectangle_creationproccess!\nBAT.integrate_hyperrectangle_cov\nBAT.issymmetric_around_origin\nBAT.log_volume\nBAT.mcmc_startval!\nBAT.modify_hypercube!\nBAT.modify_integrationvolume!\nBAT.proposal_rand!\nBAT.reduced_volume_hm\nBAT.spatialvolume\nBAT.sum_first_dim\nBAT.var_bounds\nBAT.wgt_effective_sample_size","category":"page"},{"location":"internal_api/#BAT.AbstractMCMCCallback","page":"Internal API","title":"BAT.AbstractMCMCCallback","text":"AbstractMCMCCallback <: Function\n\nBAT-internal, not part of stable public API.\n\nSubtypes (e.g. X) must support\n\n(::X)(level::Integer, chain::MCMCIterator) => nothing\n(::X)(level::Integer, tuner::AbstractMCMCTuner) => nothing\n\nto be compabtible with mcmc_iterate!, mcmc_tune_burnin!, etc.\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.AbstractProposalDist","page":"Internal API","title":"BAT.AbstractProposalDist","text":"AbstractProposalDist\n\nBAT-internal, not part of stable public API.\n\nThe following functions must be implemented for subtypes:\n\nBAT.distribution_logpdf\nBAT.proposal_rand!\nValueShapes.totalndof, returning the number of DOF (i.e. dimensionality).\nLinearAlgebra.issymmetric, indicating whether p(a -> b) == p(b -> a) holds true.\n\nIn some cases, it may be desirable to override the default implementation of BAT.distribution_logpdf!.\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.BasicMvStatistics","page":"Internal API","title":"BAT.BasicMvStatistics","text":"BasicMvStatistics{T<:Real,W}\n\nBAT-internal, not part of stable public API.\n\nW must either be Weights (no bias correction) or one of AnalyticWeights, FrequencyWeights or ProbabilityWeights to specify the desired bias correction method.\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.DataSet","page":"Internal API","title":"BAT.DataSet","text":"DataSet{T<:AbstractFloat, I<:Integer}\n\nAHMI-internal, not part of stable public API.\n\nHolds the MCMC output. For construction use constructor: function DataSet{T<:Real}(data::Matrix{T}, logprob::Vector{T}, weights::Vector{T})\n\nVariables\n\n'data' : An P x N array with N data points with P parameters.\n'logprob' : The logarithmic probability for each samples stored in an array\n'weights' : How often each sample occurred. Set to an array of ones if working directly on MCMC output\n'ids' : Array which is used to assign each sample to a batch, required for the cov. weighed uncertainty estimation\n.sortids : an array of indices which stores the original ordering of the samples (the space partitioning tree reorders the samples), required to calculate an effective sample size.\n'N' : number of samples\n'P' : number of parameters\n'nsubsets' : the number of batches\n'iswhitened' : a boolean value which indicates whether the data set is iswhitened\n'isnew' : a boolean value which indicates whether the data set was swapped out with a different one (it is possible to redo the integration with a different sample set using previously generated hyper-rectangles)\n'partitioningtree' : The space partitioning tree, used to efficiently identify samples in a point cloud\n'startingIDs' : The Hyper-Rectangle Seed Samples are stored in this array\n'tolerance' : A threshold required for the hyper-rectangle creation process.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.HMIData","page":"Internal API","title":"BAT.HMIData","text":"HMIData{T<:AbstractFloat, I<:Integer}\n\nAHMI-internal, not part of stable public API.\n\nIncludes all the informations of the integration process, including a list of hyper-rectangles, the results of the whitening transformation, the starting ids, and the average number of points and volume of the created hyper-rectangles.\n\nVariables\n\n'dataset1' : Data Set 1\n'dataset2' : Data Set 2\n'whiteningresult' : contains the whitening matrix and its determinant, required to scale the final integral estimate\n'volumelist1' : An array of integration volumes created using dataset1, but filled with samples from dataset2\n'volumelist2' : An array of integration volumes created using dataset2, but filled with samples from dataset1\n'cubelist1' : An array of small hyper-cubes created around seeding samples of dataset 1\n'cubelist2' : An array of small hyper-cubes created around seeding samples of dataset 2\n'iterations1' : The number of volume adapting iterations for the creating volumelist1\n'iterations2' : The number of volume adapting iterations for the creating volumelist2\n'rejectedrects1' : An array of ids, indicating which hyper-rectangles of volumelist1 were rejected due to trimming\n'rejectedrects2' : An array of ids, indicating which hyper-rectangles of volumelist2 were rejected due to trimming\n'integralestimates' : A dictionary containing the final integral estimates with uncertainty estimation using different uncertainty estimators. Also includes all intermediate results required for the integral estimate combination\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.HMISettings","page":"Internal API","title":"BAT.HMISettings","text":"HMISettings\n\nAHMI-internal, not part of stable public API.\n\nholds the settings for the hm_integrate function. There are several default constructors available: HMIFastSettings() HMIStandardSettings() HMIPrecisionSettings()\n\n#Variables\n\n'whitening_method::Symbol' : which whitening method to use\n'max_startingIDs::Integer' : influences how many starting ids are allowed to be generated\n'maxstartingIDsfraction::AbstractFloat' : how many points are considered as possible starting points as a fraction of total points available\n'rect_increase::AbstractFloat' : describes the procentual rectangle volume increase/decrease during hyperrectangle creation. Low values can increase the precision if enough points are available but can cause systematically wrong results if not enough points are available.\n'useallrects::Bool' : All rectangles are used for the integration process no matter how big their overlap is. If enabled the rectangles are weighted by their overlap.\n'useMultiThreading' : activate multithreading support.\n'warning_minstartingids' : the required minimum amount of starting samples\n'dotrimming' : determines whether the integral estimates are trimmed (1σ trim) before combining them into a final result (more robust)\n'uncertaintyestimators' : A dictionary of different uncertainty estimator functions. Currently three functions are available: hmcombineresultslegacy! (outdated, overestimates uncertainty significantly in higher dimensions), hmcombineresultscovweighted! (very fast) and hmcombineresults_analyticestimation! (recommended)\n\nend\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.IntegrationVolume","page":"Internal API","title":"BAT.IntegrationVolume","text":"IntegrationVolume{T<:AbstractFloat, I<:Integer}\n\nAHMI-internal, not part of stable public API.\n\nVariables\n\n'pointcloud' : holds the point cloud of the integration volume\n'spatialvolume' : the boundaries of the integration volume\n'volume' : the volume\n\nHold the point cloud and the spatial volume for integration.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.MCMCCallbackWrapper","page":"Internal API","title":"BAT.MCMCCallbackWrapper","text":"MCMCCallbackWrapper{F} <: AbstractMCMCCallback\n\nBAT-internal, not part of stable public API.\n\nWraps a callable object to turn it into an AbstractMCMCCallback.\n\nConstructor:\n\nMCMCCallbackWrapper(f::Any)\n\nf needs to support the call syntax of an AbstractMCMCCallback.\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.MCMCSpec","page":"Internal API","title":"BAT.MCMCSpec","text":"MCMCSpec{\n    A<:MCMCAlgorithm,\n    M<:AbstractPosteriorDensity\n}\n\nBAT-internal, not part of stable public API.\n\nSpecifies a Bayesian MCMC chain.\n\nConstructor:\n\nMCMCSpec(\n    algorithm::MCMCAlgorithm,\n    posterior::AbstractPosteriorDensity\n)\n\nMarkov-chain instances, represented by objects of type MCMCIterator, are be created via\n\n(spec::MCMCSpec)(chainid::Integer)\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.OnlineMvCov","page":"Internal API","title":"BAT.OnlineMvCov","text":"OnlineMvCov{T<:AbstractFloat,W} <: AbstractMatrix{T}\n\nBAT-internal, not part of stable public API.\n\nImplementation based on variance calculation Algorithms of Welford and West.\n\nW must either be Weights (no bias correction) or one of AnalyticWeights, FrequencyWeights or ProbabilityWeights to specify the desired bias correction method.\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.OnlineMvMean","page":"Internal API","title":"BAT.OnlineMvMean","text":"OnlineMvMean{T<:AbstractFloat} <: AbstractVector{T}\n\nBAT-internal, not part of stable public API.\n\nMultivariate mean implemented via Kahan-Babuška-Neumaier summation.\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.OnlineUvMean","page":"Internal API","title":"BAT.OnlineUvMean","text":"OnlineUvMean{T<:AbstractFloat}\n\nBAT-internal, not part of stable public API.\n\nUnivariate mean implemented via Kahan-Babuška-Neumaier summation.\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.OnlineUvVar","page":"Internal API","title":"BAT.OnlineUvVar","text":"OnlineUvVar{T<:AbstractFloat,W}\n\nBAT-internal, not part of stable public API.\n\nImplementation based on variance calculation Algorithms of Welford and West.\n\nW must either be Weights (no bias correction) or one of AnalyticWeights, FrequencyWeights or ProbabilityWeights to specify the desired bias correction method.\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.PointCloud","page":"Internal API","title":"BAT.PointCloud","text":"PointCloud{T<:AbstractFloat, I<:Integer}\n\nAHMI-internal, not part of stable public API.\n\nStores the information of the points of an e.g. HyperRectVolume\n\nVariables\n\n'maxLogProb' : The maximum log. probability of one of the points inside the hyper-rectangle\n'minLogProb' : The minimum log. probability of one of the points inside the hyper-rectangle\n'maxWeightProb' : the weighted max. log. probability\n'minWeightProb' : the weighted min. log. probability\n'probfactor' : The probability factor of the hyper-rectangle\n'probweightfactor' : The weighted probability factor\n'points' : The number of points inside the hyper-rectangle\n'pointIDs' : the IDs of the points inside the hyper-rectangle, might be empty because it is optional and costs performance\n'searchres' : used to boost performance\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.SearchResult","page":"Internal API","title":"BAT.SearchResult","text":"SearchResult{T<:AbstractFloat, I<:Integer}\n\nAHMI-internal, not part of stable public API.\n\nStores the results of the space partitioning tree's search function\n\nVariables\n\n'pointIDs' : the IDs of samples found, might be empty because it is optional\n'points' : The number of points found.\n'maxLogProb' : the maximum log. probability of the points found.\n'minLogProb' : the minimum log. probability of the points found.\n'maxWeightProb' : the weighted minimum log. probability found.\n'minWeightProb' : the weighted maximum log. probfactor found.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.WhiteningResult","page":"Internal API","title":"BAT.WhiteningResult","text":"WhiteningResult{T<:AbstractFloat}\n\nAHMI-internal, not part of stable public API.\n\nStores the information obtained during the Whitening Process\n\nVariables\n\n'determinant' : The determinant of the whitening matrix\n'targetprobfactor' : The suggested target probability factor\n'whiteningmatrix' : The whitening matrix\n'meanvalue' : the mean vector of the input data\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.apply_bounds","page":"Internal API","title":"BAT.apply_bounds","text":"apply_bounds(x::<:Real, lo::<:Real, hi::<:Real, boundary_type::BoundsType)\n\nBAT-internal, not part of stable public API.\n\nApply lower/upper bound lo/hi to value x. boundary_type may be hard_bounds, cyclic_bounds or reflective_bounds.\n\n\n\napply_bounds(x::Real, interval::ClosedInterval, boundary_type::BoundsType)\n\nBAT-internal, not part of stable public API.\n\nSpecify lower and upper bound via interval.\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.apply_bounds_and_eval_posterior_logval_strict!","page":"Internal API","title":"BAT.apply_bounds_and_eval_posterior_logval_strict!","text":"BAT.apply_bounds_and_eval_posterior_logval_strict!(\n    posterior::AbstractPosteriorDensity,\n    v::AbstractVector{<:Real}\n)\n\nBAT-internal, not part of stable public API.\n\nFirst apply bounds to the parameters, then compute and return posterior log value. May modify v.\n\nGuarantees that  :\n\nIf parameters are still out of bounds after applying bounds, density_logval is not called for either prior or likelihood. \nIf density_logval for prior returns -Inf, density_logval is not called for likelihood.\n\nIn both cases, an exception is thrown.\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.apply_bounds_and_eval_posterior_logval!","page":"Internal API","title":"BAT.apply_bounds_and_eval_posterior_logval!","text":"BAT.apply_bounds_and_eval_posterior_logval!(\n    T::Type{<:Real},\n    density::AbstractDensity,\n    v::AbstractVector{<:Real}\n)\n\nBAT-internal, not part of stable public API.\n\nFirst apply bounds to the parameters, then compute and return posterior log value. May modify v.\n\nGuarantees that  :\n\nIf parameters are still out of bounds after applying bounds, density_logval is not called for either prior or likelihood. \nIf density_logval for prior returns -Inf, density_logval is not called for likelihood.\n\nIn both cases, T(-Inf) is returned for both prior and posterior.\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.apply_bounds!","page":"Internal API","title":"BAT.apply_bounds!","text":"apply_bounds!(x::AbstractVector, bounds::AbstractVarBounds)\n\nBAT-internal, not part of stable public API.\n\nApply bounds to variate/parameters x.\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.autocrl","page":"Internal API","title":"BAT.autocrl","text":"autocrl(xv::AbstractVector{T}, kv::AbstractVector{Int} = Vector{Int}())\n\nBAT-internal, not part of stable public API.\n\nautocorrelation := Σ Cov[xi,x(i+k)]/Var[x]\n\nComputes the autocorrelations at various leg k of the input vector (time series) xv. The vector kv is the collections of lags to take into account\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.bat_sampler","page":"Internal API","title":"BAT.bat_sampler","text":"bat_sampler(d::Distribution)\n\nBAT-internal, not part of stable public API.\n\nTries to return a BAT-compatible sampler for Distribution d. A sampler is BAT-compatible if it supports random number generation using an arbitrary AbstractRNG:\n\nrand(rng::AbstractRNG, s::SamplerType)\nrand!(rng::AbstractRNG, s::SamplerType, x::AbstractArray)\n\nIf no specific method of bat_sampler is defined for the type of d, it will default to sampler(d), which may or may not return a BAT-compatible sampler.\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.bg_R_2sqr","page":"Internal API","title":"BAT.bg_R_2sqr","text":"bg_R_2sqr(stats::AbstractVector{<:MCMCBasicStats}; corrected::Bool = false)\n\nBAT-internal, not part of stable public API.\n\nBrooks-Gelman R_2^2 for all DOF. If normality is assumed, 'corrected' should be set to true to account for the sampling variability.\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.find_localmodes","page":"Internal API","title":"BAT.find_localmodes","text":"find_localmodes(marg::MarginalDist)\n\nBAT-internal, not part of stable public API.\n\nFind the modes of a MarginalDist. Returns a vector of the bin-centers of the bin(s) with the heighest weight.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.get_bin_centers","page":"Internal API","title":"BAT.get_bin_centers","text":"get_bin_centers(marg::MarginalDist)\n\nBAT-internal, not part of stable public API.\n\nReturns a vector of the bin-centers.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.create_hypercube","page":"Internal API","title":"BAT.create_hypercube","text":"create_hypercube{T<:Real}(origin::Vector{T}, edgelength::T)::HyperRectVolume\n\nAHMI-internal, not part of stable public API.\n\ncreates a hypercube shaped spatial volume\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.create_hyperrectangle","page":"Internal API","title":"BAT.create_hyperrectangle","text":"create_hyperrectangle(...)\n\nAHMI-internal, not part of stable public API.\n\nThis function creates a hyper-rectangle around each starting sample. It starts by building a hyper-cube  and subsequently adapts each face individually, thus turning the hyper-cube into a hyper-rectangle. The faces are adjusted in a way to match the shape of the distribution as best as possible.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.distribution_logpdf","page":"Internal API","title":"BAT.distribution_logpdf","text":"distribution_logpdf(\n    p::AbstractArray,\n    pdist::AbstractProposalDist,\n    v_proposed::AbstractVector,\n    v_current:::AbstractVector\n)\n\nBAT-internal, not part of stable public API.\n\nAnalog to distribution_logpdf!, but for a single variate/parameter vector.\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.distribution_logpdf!","page":"Internal API","title":"BAT.distribution_logpdf!","text":"distribution_logpdf!(\n    p::AbstractArray,\n    pdist::AbstractProposalDist,\n    v_proposed::Union{AbstractVector,VectorOfSimilarVectors},\n    v_current:::Union{AbstractVector,VectorOfSimilarVectors}\n)\n\nBAT-internal, not part of stable public API.\n\nReturns log(PDF) value of pdist for transitioning from current to proposed variate/parameter arguments values for a variate/parameter sets.\n\nend\n\nInput:\n\nv_proposed: New values (column vectors)\nv_current: Old values (column vectors)\n\nOutput is stored in\n\np: Array of PDF values, length must match, shape is ignored\n\nArray size requirements:\n\nsize(v_current, 1) == size(v_proposed, 1) == length(pdist)\nsize(v_current, 2) == size(v_proposed, 2) or size(v_current, 2) == 1\nsize(v_proposed, 2) == length(p)\n\nImplementations of distribution_logpdf! must be thread-safe.\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.drop_low_weight_samples","page":"Internal API","title":"BAT.drop_low_weight_samples","text":"drop_low_weight_samples(\n    samples::DensitySampleVector,\n    fraction::Real = 10^-4\n)\n\nBAT-internal, not part of stable public API.\n\nDrop fraction of the total probability mass from samples to filter out the samples with the lowest weight.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.effective_sample_size","page":"Internal API","title":"BAT.effective_sample_size","text":"effective_sample_size(xv, w; ...)\n\nBAT-internal, not part of stable public API.\n\nEffective size estimation for a vector of samples xv. If a weight vector w is provided, the Kish approximation is applied.\n\nBy default computes the autocorrelation up to the square root of the number of entries in the vector, unless an explicit list of lags is provided (kv).\n\n\n\neffective_sample_size(variates::AbstractArray, weights::AbstractVector; with_weights=true)\n\nBAT-internal, not part of stable public API.\n\nEffective size estimation for a (multidimensional) ElasticArray. By default applies the Kish approximation with the weigths available, but can be turned off (with_weights=false).\n\n\n\neffective_sample_size(samples::DensitySampleVector; with_weights=true)\n\nBAT-internal, not part of stable public API.\n\nEffective size estimation for a (multidimensional) DensitySampleVector. By default applies the Kish approximation with the weigths available, but can be turned off (with_weights=false).\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.eval_density_logval","page":"Internal API","title":"BAT.eval_density_logval","text":"eval_density_logval(\n    density::AbstractDensity,\n    v::AbstractVector{<:Real},\n    shape::ValueShapes.AbstractValueShape\n)\n\nBAT-internal, not part of stable public API.\n\nEvaluates density log-value via density_logval.\n\nshape must be compatible with ValueShapes.varshape(density).\n\nChecks that:\n\nThe variate shape of density (if known) matches shape of v.\nThe return value of density_logval is not NaN.\nThe return value of density_logval is less than +Inf.\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.find_hypercube_centers","page":"Internal API","title":"BAT.find_hypercube_centers","text":"find_hypercube_centers(dataset::DataSet{T, I}, whiteningresult::WhiteningResult, settings::HMISettings)::Vector{I}\n\nAHMI-internal, not part of stable public API.\n\nfinds possible starting points for the hyperrectangle creation\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.fromuhc","page":"Internal API","title":"BAT.fromuhc","text":"fromuhc(X::AbstractVector, vol::SpatialVolume)\nfromuhc(X::VectorOfSimilarVectors, vol::SpatialVolume)\n\nBAT-internal, not part of stable public API.\n\nBijective transformation from unit hypercube to vol. See fromuhc!.\n\nUse inv(fromuhc) to get the the inverse transformation.\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.fromuhc!","page":"Internal API","title":"BAT.fromuhc!","text":"fromuhc!(Y::AbstractVector, X::AbstractVector, vol::SpatialVolume)\nfromuhc!(Y::VectorOfSimilarVectors, X::VectorOfSimilarVectors, vol::SpatialVolume)\n\nBAT-internal, not part of stable public API.\n\nBijective transformation of coordinates X within the unit hypercube to coordinates Y in vol. If X and Y are matrices, the transformation is applied to the column vectors. Use Y === X to transform in-place.\n\nUse inv(fromuhc!) to get the the inverse transformation.\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.fromui","page":"Internal API","title":"BAT.fromui","text":"y = fromui(x::Real, lo::Real, hi::Real)\ny = fromui(x::Real, lo_hi::ClosedInterval{<:Real})\n\nBAT-internal, not part of stable public API.\n\nLinear bijective transformation from the unit inverval (i.e. x ∈ 0..1) to y ∈ lo..hi.\n\nUse inv(fromui) to get the the inverse transformation.\n\nUse @inbounds to disable range checking on the input value.\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.getlikelihood","page":"Internal API","title":"BAT.getlikelihood","text":"getlikelihood(posterior::AbstractPosteriorDensity)::AbstractDensity\n\nBAT-internal, not part of stable public API.\n\nThe likelihood density of posterior. The likelihood may or may not be normalized.\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.getprior","page":"Internal API","title":"BAT.getprior","text":"getprior(posterior::AbstractPosteriorDensity)::AbstractDensity\n\nBAT-internal, not part of stable public API.\n\nThe prior density of posterior. The prior may or may not be normalized.\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.gr_Rsqr","page":"Internal API","title":"BAT.gr_Rsqr","text":"gr_Rsqr(stats::AbstractVector{<:MCMCBasicStats})\n\nBAT-internal, not part of stable public API.\n\nGelman-Rubin R^2 for all DOF.\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.hm_init","page":"Internal API","title":"BAT.hm_init","text":"hm_init!(result, settings)\n\nAHMI-internal, not part of stable public API.\n\nSets the global multithreading setting and ensures that a minimum number of samples, dependent on the number of dimensions, are provided.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.hm_integrate!","page":"Internal API","title":"BAT.hm_integrate!","text":"hm_integrate!(result, settings = HMIPrecisionSettings())\n\nAHMI-internal, not part of stable public API.\n\nThis function starts the adaptive harmonic mean integration. See arXiv:1808.08051 for more details. It needs a HMIData struct as input, which holds the samples, in form of a dataset, the integration volumes and other properties, required for the integration, and the final result.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.hm_whiteningtransformation!","page":"Internal API","title":"BAT.hm_whiteningtransformation!","text":"hm_whiteningtransformation!(result, settings)\n\nAHMI-internal, not part of stable public API.\n\nApplies a whitening transformation to the samples. A custom whitening method can be used by overriding settings.whitening_function!\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.hyperrectangle_creationproccess!","page":"Internal API","title":"BAT.hyperrectangle_creationproccess!","text":"hyperrectangle_creationproccess!(...)\n\nAHMI-internal, not part of stable public API.\n\nThis function assigns each thread its own hyper-rectangle to build, if in multithreading-mode.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.integrate_hyperrectangle_cov","page":"Internal API","title":"BAT.integrate_hyperrectangle_cov","text":"Estimates reducedvolumehm quantity for one hyperrectangle including estimates from batches (for covariance calculations).\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.issymmetric_around_origin","page":"Internal API","title":"BAT.issymmetric_around_origin","text":"issymmetric_around_origin(d::Distribution)\n\nBAT-internal, not part of stable public API.\n\nReturns true (resp. false) if the Distribution is symmetric (resp. non-symmetric) around the origin.\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.log_volume","page":"Internal API","title":"BAT.log_volume","text":"log_volume(vol::SpatialVolume)\n\nBAT-internal, not part of stable public API.\n\nGet the logarithm of the volume of the space in vol.\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.mcmc_startval!","page":"Internal API","title":"BAT.mcmc_startval!","text":"BAT.mcmc_startval!(\n    x::Union{AbstractVector{<:Real},VectorOfSimilarVectors{<:Real}},\n    rng::AbstractRNG,\n    posterior::AbstractPosteriorDensity,\n    algorithm::MCMCAlgorithm\n)::typeof(x)\n\nBAT-internal, not part of stable public API.\n\nFill x a random initial argument suitable for posterior and algorithm. The default implementation will try to draw the initial argument value from the prior of the posterior.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.modify_hypercube!","page":"Internal API","title":"BAT.modify_hypercube!","text":"create_hypercube!{T<:Real}(origin::Vector{T}, edgelength::T)::HyperRectVolume\n\nAHMI-internal, not part of stable public API.\n\nresizes a hypercube shaped spatial volume\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.modify_integrationvolume!","page":"Internal API","title":"BAT.modify_integrationvolume!","text":"modify_integrationvolume!(intvol::IntegrationVolume{T, I}, dataset::DataSet{T, I}, spvol::HyperRectVolume{T}, searchpts::Bool = true)\n\nAHMI-internal, not part of stable public API.\n\nupdates an integration volume with new boundaries. Recalculates the pointcloud and volume.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.proposal_rand!","page":"Internal API","title":"BAT.proposal_rand!","text":"function proposal_rand!(\n    rng::AbstractRNG,\n    pdist::GenericProposalDist,\n    v_proposed::Union{AbstractVector,VectorOfSimilarVectors},\n    v_current::Union{AbstractVector,VectorOfSimilarVectors}\n)\n\nBAT-internal, not part of stable public API.\n\nGenerate one or multiple proposed variate/parameter vectors, based on one or multiple previous vectors.\n\nInput:\n\nrng: Random number generator to use\npdist: Proposal distribution to use\nv_current: Old values (vector or column vectors, if a matrix)\n\nOutput is stored in\n\nv_proposed: New values (vector or column vectors, if a matrix)\n\nThe caller must guarantee:\n\nsize(v_current, 1) == size(v_proposed, 1)\nsize(v_current, 2) == size(v_proposed, 2) or size(v_current, 2) == 1\nv_proposed !== v_current (no aliasing)\n\nImplementations of proposal_rand! must be thread-safe.\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.reduced_volume_hm","page":"Internal API","title":"BAT.reduced_volume_hm","text":"reduced_volume_hm!(log_prob, sample_weights, volume_size, n_total, weight_total, bias_correction==true)\n\nEstimate reduced volume harmonic mean for given arguments. Includes bias corection by default. Note: Weights are expected to be frequency weights (i.e. counts).\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.spatialvolume","page":"Internal API","title":"BAT.spatialvolume","text":"spatialvolume(b::VarVolumeBounds)::SpatialVolume\n\nBAT-internal, not part of stable public API.\n\nReturns the spatial volume that defines the variate/parameter bounds.\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.sum_first_dim","page":"Internal API","title":"BAT.sum_first_dim","text":"@propagate_inbounds sum_first_dim(A::AbstractArray, j::Integer, ks::Integer...)\n\nBAT-internal, not part of stable public API.\n\nCalculate the equivalent of sum(A[:, j, ks...]).\n\n\n\n@propagate_inbounds sum_first_dim(A::AbstractArray)\n\nBAT-internal, not part of stable public API.\n\nIf A is a vector, return sum(A), else sum(A, 1)[:].\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.var_bounds","page":"Internal API","title":"BAT.var_bounds","text":"var_bounds(density::DistLikeDensity)::AbstractVarBounds\n\nBAT-internal, not part of stable public API.\n\nGet the parameter bounds of density. Must not be missing.\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.wgt_effective_sample_size","page":"Internal API","title":"BAT.wgt_effective_sample_size","text":"wgt_effective_sample_size(w::AbstractVector{T})\n\nBAT-internal, not part of stable public API.\n\nKish's approximation for weighted samples effectivesamplesize estimation. Computes the weighting factor for weigthed samples, where w is the vector of weigths.\n\n\n\n","category":"function"},{"location":"algorithms/#Algorithms-1","page":"Algorithms","title":"Algorithms","text":"","category":"section"},{"location":"algorithms/#Sampling-Algorithms-1","page":"Algorithms","title":"Sampling Algorithms","text":"","category":"section"},{"location":"algorithms/#","page":"Algorithms","title":"Algorithms","text":"TODO: List algorithms and short short descriptions.","category":"page"},{"location":"algorithms/#Integration-Algorithms-1","page":"Algorithms","title":"Integration Algorithms","text":"","category":"section"},{"location":"algorithms/#","page":"Algorithms","title":"Algorithms","text":"TODO: List algorithms and short short descriptions.","category":"page"},{"location":"algorithms/#Optimization-Algorithms-1","page":"Algorithms","title":"Optimization Algorithms","text":"","category":"section"},{"location":"algorithms/#","page":"Algorithms","title":"Algorithms","text":"TODO: List algorithms and short short descriptions.","category":"page"},{"location":"algorithms/#Other-Algorithms-1","page":"Algorithms","title":"Other Algorithms","text":"","category":"section"},{"location":"license/#License-1","page":"License","title":"License","text":"","category":"section"},{"location":"license/#","page":"License","title":"License","text":"using Markdown\nMarkdown.parse_file(joinpath(@__DIR__, \"..\", \"..\", \"LICENSE.md\"))","category":"page"},{"location":"examples/#Examples-1","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Common-Models-and-Problems-1","page":"Examples","title":"Common Models and Problems","text":"","category":"section"},{"location":"examples/#","page":"Examples","title":"Examples","text":"... to be written ...","category":"page"},{"location":"examples/#The-1-D-Gaussian-Model-1","page":"Examples","title":"The 1-D Gaussian Model","text":"","category":"section"},{"location":"examples/#","page":"Examples","title":"Examples","text":"... to be written ...","category":"page"},{"location":"examples/#The-Poisson-Problem-(Counting-Experiments)-1","page":"Examples","title":"The Poisson Problem (Counting Experiments)","text":"","category":"section"},{"location":"examples/#","page":"Examples","title":"Examples","text":"... to be written ...","category":"page"},{"location":"examples/#The-Binomial-Case-1","page":"Examples","title":"The Binomial Case","text":"","category":"section"},{"location":"examples/#","page":"Examples","title":"Examples","text":"... to be written ...","category":"page"},{"location":"examples/#...-1","page":"Examples","title":"...","text":"","category":"section"},{"location":"examples/#Published-Scientific-Examples-1","page":"Examples","title":"Published Scientific Examples","text":"","category":"section"},{"location":"examples/#","page":"Examples","title":"Examples","text":"... to be written ...","category":"page"},{"location":"examples/#A-Multivariate-Gaussian-Combination-Model-(Similar-to-BLUE)-1","page":"Examples","title":"A Multivariate Gaussian Combination Model (Similar to BLUE)","text":"","category":"section"},{"location":"examples/#","page":"Examples","title":"Examples","text":"... to be written ...","category":"page"},{"location":"examples/#The-EFTfitter-1","page":"Examples","title":"The EFTfitter","text":"","category":"section"},{"location":"examples/#","page":"Examples","title":"Examples","text":"... to be written ...","category":"page"},{"location":"plotting/#Plot-Recipes-1","page":"Plotting","title":"Plot Recipes","text":"","category":"section"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"The plot recipes described below apply for plotting samples and priors. Only the plotting of estimators (mean, standard deviation, global mode and local mode) is currently only supported for samples.","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"Also see the plotting tutorial for examples and further information on the plotting options.","category":"page"},{"location":"plotting/#D-plots-1","page":"Plotting","title":"1D plots","text":"","category":"section"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"plot(\n    samples::DensitySampleVector / prior::NamedTupleDist,\n    parsel::Union{Integer, Symbol, Expr};\n    intervals = standard_confidence_vals,\n    bins = 200,\n    normalize = true,\n    colors = standard_colors,\n    interval_labels = [],\n    mean = false,\n    std = false,\n    globalmode = false,\n    localmode = true,\n    filter = false,\n    closed = :left\n)","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"Required inputs:","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"samples::DensitySampleVector or prior::NamedTupleDist: samples (shaped or unshaped) or prior to be plotted\nparsel::Union{Integer, Symbol, Expr}: index or name of the parameter to be plotted","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"Keyword arguments:","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"seriestype::Symbol = :smallest_intervals: plot style        ","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"available seriestypes:\n* `:smallest_intervals` (default for samples), alias `:HDR`\n* `:central_intervals`\n* `:histogram`, alias `:steppost`\n* `:stephist` (default for prior)","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"nbins::Integer = 200: number of histogram bins\nnormalize::Bool = true: normalize the histogram\nintervals::Array{<:Real, 1} = [0.683, 0.955, 0.997]: probability to be enclosed in the smallest/central intervals when using the corresponding seriestypes\ncolors::Array{Symbol, 1} = [:chartreuse2, :yellow, :red]: colors of the smallest/central interval regions, in same order as the values in intervals\nmean::Union{Dict, Bool} = true: indicate mean value (currently only for samples), calculated via bat_stats().mean.","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"The plot style of the mean can be customized using a Dict.  For mean = true, the default style is:   Dict(\"linestyle\" => :solid, \"linewidth\" => 1, \"linecolor\" => :dimgrey, \"alpha\" => 1, \"label\" => \"mean\")","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"std::Union{Dict, Bool} = true: indicate the standard deviation of the mean (currently only for samples), calculated from bat_stats().cov. The style of the standard deviation can be customized using a Dict.  For std = true, the default style is:   ","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"Dict(\"fillcolor\" => :grey, \"fillalpha\" => 0.5, \"label\" => \"std. dev.\")","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"globalmode::Union{Dict, Bool} = true: indicate global mode (currently only for samples), calculated via bat_stats().mode.  The style of the global mode can be passed as a Dict.  For globalmode = true, the default style is:  ","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"Dict(\"linestyle\" => :dash, \"linewidth\" => 1, \"linecolor\" => :black, \"alpha\" => 1, \"label\" => \"global mode\")","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"localmode::Union{Dict, Bool} = true: indicate the localmode(s), i.e. the center of the highest histogram bin(s) (currently only for samples). The style can be passed as a Dict. If localmode = true, the default style is:  ","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"Dict(\"linestyle\" => :dot, \"linewidth\" => 1, \"linecolor\" => :black, \"alpha\" => 1, \"label\" => \"local mode\")","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"(only for samples) filter::Bool = false: if true, BAT.drop_low_weight_samples() is applied before plotting\nclosed = :left: see StatsBase.Histogram","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"Keyword arguments for attributes supported by Plots.jl can also be passed to the function.","category":"page"},{"location":"plotting/#D-plots-2","page":"Plotting","title":"2D plots","text":"","category":"section"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"plot(\n    samples::DensitySampleVector / prior::NamedTupleDist,\n    parsel::Union{NTuple{2, Integer}, NTuple{2, Union{Symbol, Expr}}};\n    intervals = standard_confidence_vals,\n\tinterval_labels = [],\n    colors = standard_colors,\n    mean = false,\n    std = false,\n    globalmode = false,\n    localmode = true,\n    diagonal = Dict(),\n    upper = Dict(),\n    right = Dict(),\n    filter = false,\n    closed = :left\n)","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"Required inputs:","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"samples::DensitySampleVector or prior::NamedTupleDist: samples (shaped or unshaped) or prior to be plotted\nparsel::Union{NTuple{2, Integer}, NTuple{2, Union{Symbol, Expr}}}: indices or names of the two parameters to be plotted","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"Keyword arguments:","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"seriestype::Symbol = :smallest_intervals: plot style  ","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"available seriestypes:\n* `:smallest_intervals` (default for samples)\n* `:smallest_intervals_contour` (default for prior)\n* `:smallest_intervals_contourf`: filled contours)\n* `:histogram`, alias `:hist`, alias `:histogram2d`\n* `:scatter`","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"nbins::Union{Integer, NTuple{2, Integer}} = 200: number of histogram bins, use a NTuple{2, Integer} to specify bins of x and y axes seperately\nnormalize::Bool = true: normalize the histogram\nintervals::Array{<:Real, 1} = [0.683, 0.955, 0.997]  probability to be enclosed in the smallest intervals when using the corresponding seriestypes\ninterval_labels = []  label of the intervals as strings, LatexStrings are possible.\ncolors::Array{Symbol, 1} = [:chartreuse2, :yellow, :red] colors of the smallest interval regions, in same order as the values in intervals\nmean::Union{Dict, Bool} = true: indicate mean value (currently only for samples) , calculated via bat_stats().mean.","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"The plot style of the mean can be customized using a Dict.  For mean = true, the default style is: Dict(\"markercolor\" => :black, \"markersize\" => 4, \"markeralpha\" => 1, \"markershape\" => :circle, \"markerstrokealpha\" => 1, \"markerstrokecolor\" => :black, \"markerstrokestyle\" => :solid, \"markerstrokewidth\" => 1, \"label\" => \"mean\")","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"std::Union{Bool} = true: indicate the standard deviation of the mean as errorbars (currently only for samples), calculated from bat_stats().cov. The style of the errorbars can be customized using the markerstroke... options in mean.\nglobalmode::Union{Dict, Bool} = true: indicate global mode (currently only for samples), calculated via bat_stats().mode.  The style of the global mode can be passed as a Dict.  For globalmode = true, the default style is:","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"Dict(\"linestyle\" => :dash, \"linewidth\" => 1, \"linecolor\" => :black, \"alpha\" => 1, \"label\" => \"global mode\")","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"localmode::Union{Dict, Bool} = true: indicate the localmode(s), i.e. the center of the highest histogram bin(s) (currently only for samples). The style can be passed as a Dict. If localmode = true, the default style is:","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"Dict(\"linestyle\" => :dot, \"linewidth\" => 1, \"linecolor\" => :black, \"alpha\" => 1, \"label\" => \"local mode\")","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"diagonal = Dict(): Used only for the seriestype :marginal. The dictionary can contain the seriestypes and plot options for 2D distributions explained above to modify the 2D plot of the marginal plot. Nested Dictionaries are possible to modify the styles of the estimators as described above\nupper = Dict() and right = Dict():  Used only for the seriestype :marginal. The dictionaries can contain the seriestypes and plot options for 1D distributions explained above to modify the upper and right plots of the 1D marginal distributions. Nested Dictionaries are possible to modify the styles of the estimators as described above\nfilter::Bool = false: if true, BAT.drop_low_weight_samples() is applied before plotting\nclosed = :left: see StatsBase.Histogram","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"Keyword arguments for attributes supported by Plots.jl can also be passed to the function.","category":"page"},{"location":"plotting/#D-and-2D-overview-plots-1","page":"Plotting","title":"1D & 2D overview plots","text":"","category":"section"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"plot(\n\tsamples::DensitySampleVector / prior::NamedTupleDist;\n    vsel=collect(1:5),\n    mean=false,\n    std=false,\n    globalmode=false,\n    localmode=false,\n    diagonal = Dict(),\n    upper = Dict(),\n    lower = Dict(),\n    vsel_label = []\n)","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"Plot a grid with the 1D marginalized distributions on the diagonal and all combinations of the 2D marginalized distributions in the lower and upper triangle.","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"Required inputs:","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"samples::DensitySampleVector or prior::NamedTupleDist: samples (shaped or unshaped) or prior to be plotted","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"Keyword arguments:","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"vsel::Array{Integer, 1} = collect(1:5): indices of the parameters to be plotted. By default (up to) the first five parameters are plotted.\nmean::Bool = false: Indicate mean value, calculated via  bat_stats().mean, in all plots (currently only for samples)\nstd::Bool = false: Indicate the standard deviation of the mean calculated from bat_stats().cov in all plots (currently only for samples)\nglobalmode::Bool = false: Indicate global mode, calculated via bat_stats().mode, in all plots (currently only for samples)\nlocalmode::Bool = false: Indicate local mode(s), i.e. the center of the highest histogram bin(s), in all plots (currently only for samples)\ndiagonal = Dict(): The dictionary can contain the seriestypes and plot options for 1D distributions explained above to modify the plots of the 1D marginal distributions on the diagonal of the grid. Nested Dictionaries are possible to modify the styles of the estimators as described above\nlower = Dict() and upper = Dict():  The dictionaries can contain the seriestypes and plot options for 2D distributions explained above to modify the 2D plots in the lower and upper triangles of the grid. Nested Dictionaries are possible to modify the styles of the estimators as described above\nvsel_label = []: parameter label as strings, LatexStrings are possible","category":"page"},{"location":"experimental_api/#Experimental-features-1","page":"Experimental Features","title":"Experimental features","text":"","category":"section"},{"location":"experimental_api/#","page":"Experimental Features","title":"Experimental Features","text":"These are experimental features. Forward/backward compatibility does not follow Julia's semantic versioning rules. Instead, compatibility is only guaranteed across changes in patch version, but not across changes of minor (or major) version changes.","category":"page"},{"location":"experimental_api/#","page":"Experimental Features","title":"Experimental Features","text":"BAT.ExternalDensity\nHierarchicalDensity","category":"page"},{"location":"experimental_api/#BAT.ExternalDensity","page":"Experimental Features","title":"BAT.ExternalDensity","text":"BAT.ExternalDensity <: AbstractDensity\n\nExperimental feature, not part of stable public API.\n\nUses an external program to calculate log-density values, the program must support the BAT binary communication protocol.\n\nConstructor:\n\nExternalDensity(cmd::Cmd, density_id::Integer = 0)\n\n\n\n","category":"type"},{"location":"experimental_api/#BAT.HierarchicalDensity","page":"Experimental Features","title":"BAT.HierarchicalDensity","text":"HierarchicalDensity <: DistLikeDensity\n\nA hierarchical density, useful for hierarchical models/priors.\n\nConstructors:\n\nHierarchicalDensity(f::Function, parent_density::DistLikeDensity)\n\nwith a functon f that returns a DistLikeDensity for any variate v drawn from parent_dist.\n\nDistributions are automatically converted to DistLikeDensitys. varshape(parent_density) and varshape(f(v)) must be a NamedTupleShape.\n\nExample:\n\nhd = HierarchicalDensity(\n    v -> NamedTupleDist(\n        baz = fill(Normal(v.bar, v.foo), 3)\n    ),\n    NamedTupleDist(\n        foo = Exponential(3.5),\n        bar = Normal(2.0, 1.0)\n    )\n)\n\nvarshape(hd) == NamedTupleShape(\n    foo = ScalarShape{Real}(),\n    bar = ScalarShape{Real}(),\n    baz = ArrayShape{Real}(3)\n)\n\nv = rand(sampler(hd))\nBAT.density_logval(hd, v)\n)\n\n\n\n\n\n","category":"type"},{"location":"#BAT.jl-Documentation-1","page":"Home","title":"BAT.jl Documentation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"BAT.jl stands for Bayesian Analysis Toolkit in Julia. It is a high high-performance tool box for Bayesian inference with statistical models expressed in a general-purpose programming language, instead of a domain-specific language.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Typical applications for this package are the extraction of the values of the parameters of a model, the comparison of different models in the light of a given data set and the test of the validity of a model to represent the data set at hand. BAT.jl provides access to the full Bayesian posterior distribution to enable parameter estimation, limit setting and uncertainty propagation. BAT.jl also provides supporting functionality like plotting recipes and reporting functions.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"BAT.jl is implemented in pure Julia and allows for a flexible definition of mathematical models and applications while enabling the user to code for the performance required for computationally expensive numerical operations. BAT.jl provides implementations (internally and via other Julia packages) of algorithms for sampling, optimization and integration. A few predefined models will be  provided for standard cases such as histogram fitting and simple counting experiments (work in progress), but BAT's main focus is on the analysis of complex custom models. It is designed to enable multi-threaded and distributed (work in progress) code execution at various levels, running multiple MCMC chains in parallel is provided out-of-the-box.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"It's possible to use BAT.jl with likelihood functions implemented in languages other than Julia: Julia allows for calling code in C and Fortran, C++, Python and several other languages directly. In addition, BAT.jl provides (as an experimental feature) a very lightweight binary RPC protocol that is easy to implement, to call non-Julia functions written in any language, running in separate processes.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"note: Note\nBAT.jl requires Julia >= v1.3.","category":"page"},{"location":"#History-and-Status-1","page":"Home","title":"History and Status","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"BAT.jl is a complete rewrite of BAT, the Bayesian Analysis Toolkit in C++. BAT.jl is still a work in progress: It already provides several improvements over it's C++ predecessor, but has not yet reached feature parity.","category":"page"},{"location":"#Table-of-contents-1","page":"Home","title":"Table of contents","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\n    # \"basics.md\",\n    \"installation.md\",\n    \"tutorial.md\",\n    # \"faq.md\",\n    # \"examples.md\",\n    # \"algorithms.md\",\n    # \"benchmarks.md\",\n    # \"publications.md\",\n    \"api.md\",\n    \"developing.md\",\n    \"license.md\",\n]\nDepth = 1","category":"page"},{"location":"#Citing-BAT.jl-1","page":"Home","title":"Citing BAT.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"When using BAT.jl for work that will result in a scientific publication, please cite","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Caldwell et al., BAT.jl - A Bayesian Analysis Toolkit in Julia, doi:10.5281/zenodo.2605312","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The DOI above is version-independent, you may want to use the DOI of the specific BAT.jl version used in your work.","category":"page"},{"location":"#Learning-(more-about)-Julia-1","page":"Home","title":"Learning (more about) Julia","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"BAT.jl is intended to supersede BAT in C++, long term. If you're considering to switch to BAT.jl but you're new to Julia and want to learn more about the the language, here are a few resources to get started:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The Julia website provides many links to introductory videos and written tutorials, e.g. \"Intro to Julia\", \"A Deep Introduction to Julia for Data Science and Scientific Computing\" and \"The Fast Track to Julia 1.0\". If you are familar with MATLAB or Python, you may also want to take a look at the \"MATLAB–Python–Julia cheatsheet\".","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Note: Try to avoid tutorials and books written for older versions of Julia, as there have been quite a few changes to the language in v1.0.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"There are also a lot of interesting talks and tutorials on the Julia YouTube Channel. Have a look at the talks at JuliaCon 2018 to get an impression on the kinds of scientific applications Julia is being used for and why, e.g. \"Why Julia is the most suitable language for science\".","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The in-depth article Why Numba and Cython are not substitutes for Julia explains how Julia addresses several fundamental challenges inherent to scientific high-performance computing.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"If you want to get an impression of the attention to detail so typical for Julia, watch \"0.1 vs 1//10: How numbers are compared\".","category":"page"},{"location":"#Acknowledgements-1","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"We acknowledge the contributions from all the BAT.jl users, they help us make BAT.jl a better project. Your help is most welcome!","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Development of BAT.jl has been supported by funding from","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Deutsche Forschungsgemeinschaft (DFG, German Research Foundation)","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"EditURL = \"https://github.com/bat/BAT.jl/blob/master/docs/src/tutorial_lit.jl\"","category":"page"},{"location":"tutorial/#Tutorial-1","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"This tutorial demonstrates a simple application of BAT.jl: A Bayesian fit of a histogram with two Gaussian peaks.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"You can also download this tutorial as a Jupyter notebook and a plain Julia source file.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Table of contents:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Pages = [\"tutorial.md\"]\nDepth = 3","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Note: This tutorial is somewhat verbose, as it aims to be easy to follow for users who are new to Julia. For the same reason, we deliberately avoid making use of Julia features like closures, anonymous functions, broadcasting syntax, performance annotations, etc.","category":"page"},{"location":"tutorial/#Input-Data-Generation-1","page":"Tutorial","title":"Input Data Generation","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"First, let's generate some synthetic data to fit. We'll need the Julia standard-library packages \"Random\", \"LinearAlgebra\" and \"Statistics\", as well as the packages \"Distributions\" and \"StatsBase\":","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"using Random, LinearAlgebra, Statistics, Distributions, StatsBase","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"As the underlying truth of our input data/histogram, let us choose an non-normalized probability density composed of two Gaussian peaks with a peak area of 500 and 1000, a mean of -1.0 and 2.0 and a standard error of 0.5","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"data = vcat(\n    rand(Normal(-1.0, 0.5), 500),\n    rand(Normal( 2.0, 0.5), 1000)\n)","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"resulting in a vector of floating-point numbers:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"typeof(data) == Vector{Float64}","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Next, we'll create a histogram of that data, this histogram will serve as the input for the Bayesian fit:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"hist = append!(Histogram(-2:0.1:4), data)","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Using the Julia \"Plots\" package","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"using Plots","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"we can plot the histogram:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"plot(\n    normalize(hist, mode=:density),\n    st = :steps, label = \"Data\",\n    title = \"Data\"\n)\nsavefig(\"tutorial-data.pdf\")\nsavefig(\"tutorial-data.svg\"); nothing # hide","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"(Image: Data)","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Let's define our fit function - the function that we expect to describe the data histogram, at each x-Axis position x, depending on a given set p of model parameters:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"function fit_function(p::NamedTuple{(:a, :mu, :sigma)}, x::Real)\n    p.a[1] * pdf(Normal(p.mu[1], p.sigma), x) +\n    p.a[2] * pdf(Normal(p.mu[2], p.sigma), x)\nend\nnothing # hide","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"The fit parameters (model parameters) a (peak areas) and mu (peak means) are vectors, parameter sigma (peak width) is a scalar, we assume it's the same for both Gaussian peaks.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"The true values for the model/fit parameters are the values we used to generate the data:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"true_par_values = (a = [500, 1000], mu = (-1.0, 2.0), sigma = 0.5)\nnothing # hide","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Let's visually compare the histogram and the fit function, using these true parameter values, to make sure everything is set up correctly:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"plot(\n    normalize(hist, mode=:density),\n    st = :steps, label = \"Data\",\n    title = \"Data and True Statistical Model\"\n)\nplot!(\n    -4:0.01:4, x -> fit_function(true_par_values, x),\n    label = \"Truth\"\n)\nsavefig(\"tutorial-data-and-truth.pdf\")\nsavefig(\"tutorial-data-and-truth.svg\"); nothing # hide","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"(Image: Data and True Statistical Model)","category":"page"},{"location":"tutorial/#Bayesian-Fit-1","page":"Tutorial","title":"Bayesian Fit","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Now we'll perform a Bayesian fit of the generated histogram, using BAT, to infer the model parameters from the data histogram.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"In addition to the Julia packages loaded above, we need BAT itself, as well as IntervalSets:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"using BAT, IntervalSets","category":"page"},{"location":"tutorial/#Likelihood-Definition-1","page":"Tutorial","title":"Likelihood Definition","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"First, we need to define the likelihood (function) for our problem.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"BAT represents densities like likelihoods and priors as subtypes of BAT.AbstractDensity. Custom likelihood can be defined by creating a new subtype of AbstractDensity and by implementing (at minimum) BAT.density_logval for that type - in complex uses cases, this may become necessary. Typically, however, it is sufficient to define a custom likelihood as a simple function that returns the log-likelihood value for a given set of parameters. BAT will automatically convert such a likelihood function into a subtype of AbstractDensity.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"For performance reasons, functions should not access global variables directly. So we'll use an anonymous function inside of a let-statement to capture the value of the global variable hist in a local variable h (and to shorten function name fit_function to f, purely for convenience). The likelihood function wraps it's result in a LogDVal to indicate that it returns a log-likelihood value:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"likelihood = let h = hist, f = fit_function\n    # Histogram counts for each bin as an array:\n    observed_counts = h.weights\n\n    # Histogram binning:\n    bin_edges = h.edges[1]\n    bin_edges_left = bin_edges[1:end-1]\n    bin_edges_right = bin_edges[2:end]\n    bin_widths = bin_edges_right - bin_edges_left\n    bin_centers = (bin_edges_right + bin_edges_left) / 2\n\n    params -> begin\n        # Log-likelihood for a single bin:\n        function bin_log_likelihood(i)\n            # Simple mid-point rule integration of fit function `f` over bin:\n            expected_counts = bin_widths[i] * f(params, bin_centers[i])\n            logpdf(Poisson(expected_counts), observed_counts[i])\n        end\n\n        # Sum log-likelihood over bins:\n        idxs = eachindex(observed_counts)\n        ll_value = bin_log_likelihood(idxs[1])\n        for i in idxs[2:end]\n            ll_value += bin_log_likelihood(i)\n        end\n\n        # Wrap `ll_value` in `LogDVal` so BAT knows it's a log density-value.\n        return LogDVal(ll_value)\n    end\nend","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"BAT makes use of Julia's parallel programming facilities if possible, e.g. to run multiple Markov chains in parallel. Therefore, log-likelihood (and other) code must be thread-safe. Mark non-thread-safe code with @critical (provided by Julia package ParallelProcessingTools).","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Support for automatic parallelization across multiple (local and remote) Julia processes is planned, but not implemented yet.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Note that Julia currently starts only a single thread by default. Set the the environment variable JULIA_NUM_THREADS to specify the desired number of Julia threads.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"We can evaluate likelihood, e.g. for the true parameter values:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"likelihood(true_par_values)","category":"page"},{"location":"tutorial/#Prior-Definition-1","page":"Tutorial","title":"Prior Definition","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Next, we need to choose a sensible prior for the fit:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"using ValueShapes\n\nprior = NamedTupleDist(\n    # a = [0.0..10.0^4, 0.0..10.0^4],\n    a = [Weibull(1.1, 5000), Weibull(1.1, 5000)],\n    mu = [-2.0..0.0, 1.0..3.0],\n    # mu = [Normal(-3, 4), Normal(-3, 4)],\n    # sigma = Truncated(Normal(0.4, 2), 0.3, 0.7)\n    sigma = Weibull(1.2, 2)\n)\n\nnothing # hide","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"In general, BAT allows instances of any subtype of AbstractDensity to be uses as a prior, as long as a sampler is defined for it. This way, users may implement complex application-specific priors. You can also use convert(AbstractDensity, distribution) to convert any continuous multivariate Distributions.Distribution to a BAT.AbstractDensity that can be used as a prior (or likelihood).","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"The prior also implies the shapes of the parameters:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"parshapes = varshape(prior)","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"These will come in handy later on, e.g. to access (the posterior distribution of) individual parameter values.","category":"page"},{"location":"tutorial/#Bayesian-Model-Definition-1","page":"Tutorial","title":"Bayesian Model Definition","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Given the likelihood and prior definition, a BAT.PosteriorDensity is simply defined via","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"posterior = PosteriorDensity(likelihood, prior)\nnothing # hide","category":"page"},{"location":"tutorial/#Parameter-Space-Exploration-via-MCMC-1","page":"Tutorial","title":"Parameter Space Exploration via MCMC","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"We can now use Markov chain Monte Carlo (MCMC) to explore the space of possible parameter values for the histogram fit.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"To increase the verbosity level of BAT logging output, you may want to set the Julia logging level for BAT to debug via ENV[\"JULIA_DEBUG\"] = \"BAT\".","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Let's use 4 MCMC chains and require 10^5 unique samples from each chain (after tuning/burn-in):","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"nsamples = 10^4\nnchains = 4\nnothing # hide","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Now we can generate a set of MCMC samples via bat_sample:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"samples = bat_sample(posterior, (nsamples, nchains), MetropolisHastings()).result\nnothing # hide","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Let's calculate some statistics on the posterior samples:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"println(\"Truth: $true_par_values\")\nprintln(\"Mode: $(mode(samples))\")\nprintln(\"Mean: $(mean(samples))\")\nprintln(\"Stddev: $(std(samples))\")","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Internally, BAT often needs to represent variates as flat real-valued vectors:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"unshaped.(samples).v","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"BAT uses ValueShapes.jl to implement a dual view of variate values in both shaped and unshaped form, based on shape inferred from the prior and propagated to the posterior. Shaped and unshaped samples are views of the same data in memory. The variate/parameter shape can be accessed via","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"parshapes = varshape(posterior)","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"The statisics above (mode, mean and std-dev) are presented in shaped form. However, it's not possible to represent statistics with matrix shape, e.g. the parameter covariance matrix, this way. So the covariance has to be accessed in unshaped form:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"par_cov = cov(unshaped.(samples))\nprintln(\"Covariance: $par_cov\")","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Our parshapes is a NamedTupleShape. It's properties (i.e. individual parameter accessors) can be used as indices to query the covariance between specific parameters:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"par_cov[parshapes.mu, parshapes.sigma]","category":"page"},{"location":"tutorial/#Visualization-of-Results-1","page":"Tutorial","title":"Visualization of Results","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"BAT.jl comes with an extensive set of plotting recipes for \"Plots.jl\". We can plot the marginalized distribution for a single parameter (e.g. parameter 3, i.e. μ[1]):","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"plot(\n    samples, :(mu[1]),\n    mean = true, std = true, globalmode = true, localmode = true,\n    nbins = 50, title = \"Marginalized Distribution for mu[1]\"\n)\nsavefig(\"tutorial-single-par.pdf\")\nsavefig(\"tutorial-single-par.svg\"); nothing # hide","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"(Image: Marginalized Distribution for mu_1)","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"or plot the marginalized distribution for a pair of parameters (e.g. parameters 3 and 5, i.e. μ[1] and σ), including information from the parameter stats:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"plot(\n    samples, (:(mu[1]), :sigma),\n    mean = true, std = true, globalmode = true, localmode = true,\n    nbins = 50, title = \"Marginalized Distribution for mu[1] and sigma\"\n)\nplot!(BAT.MCMCBasicStats(samples), (3, 5))\nsavefig(\"tutorial-param-pair.png\")\nsavefig(\"tutorial-param-pair.svg\"); nothing # hide","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"(Image: Marginalized Distribution for mu_1 and sigma)","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"We can also create an overview plot of the marginalized distribution for all pairs of parameters:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"plot(\n    samples,\n    mean = false, std = false, globalmode = true, localmode = false,\n    nbins = 50\n)\nsavefig(\"tutorial-all-params.png\")\nsavefig(\"tutorial-all-params.svg\"); nothing # hide","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"(Image: Pairwise Correlation between Parameters)","category":"page"},{"location":"tutorial/#Integration-with-Tables.jl-1","page":"Tutorial","title":"Integration with Tables.jl","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"DensitySamplesVector supports the Tables.jl interface, so it is a table itself. We can also convert it to other table types, e.g. a TypedTables.Table:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"using TypedTables\n\ntbl = Table(samples)","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"or a DataFrames.DataFrame, etc.","category":"page"},{"location":"tutorial/#Comparison-of-Truth-and-Best-Fit-1","page":"Tutorial","title":"Comparison of Truth and Best Fit","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"As a final step, we retrieve the parameter values at the mode, representing the best-fit parameters","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"samples_mode = mode(samples)","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Like the samples themselves, the result can be viewed in both shaped and unshaped form. samples_mode is presented as a 0-dimensional array that contains a NamedTuple, this representation preserves the shape information:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"samples_mode[] isa NamedTuple\n\nunshaped(samples_mode)","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"samples_mode is only an estimate of the mode of the posterior distribution. It can be further refined using bat_findmode:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"findmode_result = bat_findmode(posterior, initial_mode = samples_mode)\n\nfit_par_values = findmode_result.result[]","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Let's plot the data and fit function given the true parameters and MCMC samples","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"plot(-4:0.01:4, fit_function, samples)\n\nplot!(\n    normalize(hist, mode=:density),\n    color=1, linewidth=2, fillalpha=0.0,\n    st = :steps, fill=false, label = \"Data\",\n    title = \"Data, True Model and Best Fit\"\n)\n\nplot!(-4:0.01:4, x -> fit_function(true_par_values, x), color=4, label = \"Truth\")\nsavefig(\"tutorial-data-truth-bestfit.pdf\")\nsavefig(\"tutorial-data-truth-bestfit.svg\"); nothing # hide","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"(Image: Data, True Model and Best Fit)","category":"page"},{"location":"tutorial/#Fine-grained-control-1","page":"Tutorial","title":"Fine-grained control","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"BAT provides fine-grained control over the MCMC algorithm options, the MCMC chain initialization, tuning/burn-in strategy and convergence testing. All option value used in the following are the default values, any or all may be omitted.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"We'll sample using the The Metropolis-Hastings MCMC algorithm:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"algorithm = MetropolisHastings()\nnothing # hide","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"BAT requires a counter-based random number generator (RNG), since it partitions the RNG space over the MCMC chains. This way, a single RNG seed is sufficient for all chains and results are reproducible even under parallel execution. By default, BAT uses a Philox4x RNG initialized with a random seed drawn from the system entropy pool:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"using Random123\nrng = Philox4x()\nnothing # hide","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Other default parameters are:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"tuning = AdaptiveMetropolisTuning(\n    λ = 0.5,\n    α = 0.15..0.35,\n    β = 1.5,\n    c = 1e-4..1e2,\n    r = 0.5\n)\n\nconvergence = BrooksGelmanConvergence(\n    threshold = 1.1,\n    corrected = false\n)\n\ninit = MCMCInitStrategy(\n    init_tries_per_chain = 8..128,\n    max_nsamples_init = 25,\n    max_nsteps_init = 250,\n    max_time_init = Inf\n)\n\nburnin = MCMCBurninStrategy(\n    max_nsamples_per_cycle = 1000,\n    max_nsteps_per_cycle = 10000,\n    max_time_per_cycle = Inf,\n    max_ncycles = 30\n)\n\nnothing # hide","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"To generate MCMC samples with explicit control over all options, use","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"samples = bat_sample(\n    rng, posterior, (nsamples, nchains), algorithm,\n    max_nsteps = 10 * nsamples,\n    max_time = Inf,\n    tuning = tuning,\n    init = init,\n    burnin = burnin,\n    convergence = convergence,\n    strict = false,\n    filter = true\n).result\nnothing # hide","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"However, in many use cases, simply using the default options via","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"samples = bat_sample(posterior, (nsamples, nchains), MetropolisHastings()).result","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"will often be sufficient.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"This page was generated using Literate.jl.","category":"page"}]
}
